<?xml version="1.0"?>
<doc>
    <assembly>
        <name>iAnywhere.Data.SQLAnywhere.v3.5</name>
    </assembly>
    <members>
        <member name="T:iAnywhere.Data.SQLAnywhere.SARowsCopiedEventArgs">
            <summary>
            <para>Represents the set of arguments passed to the SARowsCopiedEventHandler.</para>
        </summary><remarks>
            <para>The SARowsCopiedEventArgs class is not available in the .NET Compact Framework 2.0.</para>
        </remarks>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SARowsCopiedEventArgs.#ctor(System.Int64)">
            <summary>
            <para>Creates a new instance of the SARowsCopiedEventArgs object.</para>
        </summary><remarks>
            <para>The SARowsCopiedEventArgs class is not available in the .NET Compact Framework 2.0.</para>
        </remarks><param name="rowsCopied">
            An 64-bit integer value that indicates the number of rows copied during the current bulk-copy operation. 
        </param>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SARowsCopiedEventArgs.Abort">
            <summary>
            <para>Gets or sets a value that indicates whether the bulk-copy operation should be aborted.</para>
        </summary><remarks>
            <para>The SARowsCopiedEventArgs class is not available in the .NET Compact Framework 2.0.</para>
        </remarks>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SARowsCopiedEventArgs.RowsCopied">
            <summary>
            <para>Gets the number of rows copied during the current bulk-copy operation.</para>
        </summary><remarks>
            <para>The SARowsCopiedEventArgs class is not available in the .NET Compact Framework 2.0.</para>
        </remarks>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SARowsCopiedEventHandler">
            <summary>
            <para>Represents the method that handles the SABulkCopy.SARowsCopied event of an SABulkCopy.</para>
        </summary><remarks>
            <para>The SARowsCopiedEventHandler delegate is not available in the .NET Compact Framework 2.0.</para>
        </remarks><seealso cref="T:iAnywhere.Data.SQLAnywhere.SABulkCopy"/>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SABulkCopy">
            <summary>
            <para>Efficiently bulk load a SQL Anywhere table with data from another source.</para>
        </summary><remarks>
            <para>The SABulkCopy class is not available in the .NET Compact Framework 2.0.</para>
            <para><b>Implements: </b> <see cref="T:System.IDisposable"/></para>
        </remarks>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SABulkCopy.#ctor(iAnywhere.Data.SQLAnywhere.SAConnection)">
            <summary>
            <para>Initializes an SABulkCopy object.</para>
        </summary><remarks>
            <para>The SABulkCopy class is not available in the .NET Compact Framework 2.0.</para>
        </remarks><param name="connection">
            The already open SAConnection that will be used to perform the bulk-copy operation. If the connection is not open, an exception is thrown in WriteToServer. 
        </param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SABulkCopy.#ctor(System.String)">
            <summary>
            <para>Initializes an SABulkCopy object.</para>
        </summary><remarks>
            <para>This syntax opens a connection during WriteToServer using connectionString. The connection is closed at the end of WriteToServer.</para>
            <para>The SABulkCopy class is not available in the .NET Compact Framework 2.0.</para>
        </remarks><param name="connectionString">
            The string defining the connection that will be opened for use by the SABulkCopy instance. A connection string is a semicolon-separated list of keyword=value pairs. 
        </param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SABulkCopy.#ctor(System.String,iAnywhere.Data.SQLAnywhere.SABulkCopyOptions)">
            <summary>
            <para>Initializes an SABulkCopy object.</para>
        </summary><remarks>
            <para>This syntax opens a connection during WriteToServer using connectionString. The connection is closed at the end of WriteToServer. The copyOptions parameter has the effects described above.</para>
            <para>The SABulkCopy class is not available in the .NET Compact Framework 2.0.</para>
        </remarks><param name="connectionString">
            The string defining the connection that will be opened for use by the SABulkCopy instance. A connection string is a semicolon-separated list of keyword=value pairs. 
        </param><param name="copyOptions">
            A combination of values from the SABulkCopyOptions enumeration that determines which data source rows are copied to the destination table. 
        </param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SABulkCopy.#ctor(iAnywhere.Data.SQLAnywhere.SAConnection,iAnywhere.Data.SQLAnywhere.SABulkCopyOptions,iAnywhere.Data.SQLAnywhere.SATransaction)">
            <summary>
            <para>Initializes an SABulkCopy object.</para>
        </summary><remarks>
            <para>The SABulkCopy class is not available in the .NET Compact Framework 2.0.</para>
        </remarks><param name="connection">
            The already open SAConnection that will be used to perform the bulk-copy operation. If the connection is not open, an exception is thrown in WriteToServer. 
        </param><param name="copyOptions">
            A combination of values from the SABulkCopyOptions enumeration that determines which data source rows are copied to the destination table. 
        </param><param name="externalTransaction">
            An existing SATransaction instance under which the bulk copy will occur. If externalTransaction is not NULL, then the bulk-copy operation is done within it. It is an error to specify both an external transaction and the UseInternalTransaction option. 
        </param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SABulkCopy.Finalize">
            <summary>
            <para>Destructs an SABulkCopy object.</para>
        </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SABulkCopy.Dispose">
            <summary>
            <para>Disposes of the SABulkCopy instance.</para>
        </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SABulkCopy.Close">
            <summary>
            <para>Closes the SABulkCopy instance.</para>
        </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SABulkCopy.WriteToServer(System.Data.DataRow[])">
            <summary>
            <para>Copies all rows in the supplied array of <see cref="T:System.Data.DataRow"/> objects to a destination table specified by the DestinationTableName property of the SABulkCopy object.</para>
        </summary><remarks>
            <para>The SABulkCopy class is not available in the .NET Compact Framework 2.0.</para>
        </remarks><param name="rows">
            An array of System.Data.DataRow objects that will be copied to the destination table. 
        </param><seealso cref="P:iAnywhere.Data.SQLAnywhere.SABulkCopy.DestinationTableName"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SABulkCopy.WriteToServer(System.Data.DataTable)">
            <summary>
            <para>Copies all rows in the supplied <see cref="T:System.Data.DataTable"/> to a destination table specified by the DestinationTableName property of the SABulkCopy object.</para>
        </summary><remarks>
            <para>The SABulkCopy class is not available in the .NET Compact Framework 2.0.</para>
        </remarks><param name="table">
            A System.Data.DataTable whose rows will be copied to the destination table. 
        </param><seealso cref="P:iAnywhere.Data.SQLAnywhere.SABulkCopy.DestinationTableName"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SABulkCopy.WriteToServer(System.Data.IDataReader)">
            <summary>
            <para>Copies all rows in the supplied <see cref="T:System.Data.IDataReader"/> to a destination table specified by the DestinationTableName property of the SABulkCopy object.</para>
        </summary><remarks>
            <para>The SABulkCopy class is not available in the .NET Compact Framework 2.0.</para>
        </remarks><param name="reader">
            A System.Data.IDataReader whose rows will be copied to the destination table. 
        </param><seealso cref="P:iAnywhere.Data.SQLAnywhere.SABulkCopy.DestinationTableName"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SABulkCopy.WriteToServer(System.Data.DataTable,System.Data.DataRowState)">
            <summary>
            <para>Copies all rows in the supplied <see cref="T:System.Data.DataTable"/> with the specified row state to a destination table specified by the DestinationTableName property of the SABulkCopy object.</para>
        </summary><remarks>
            <para>Only those rows matching the row state are copied.</para>
            <para>The SABulkCopy class is not available in the .NET Compact Framework 2.0.</para>
        </remarks><param name="table">
            A System.Data.DataTable whose rows will be copied to the destination table. 
        </param><param name="rowState">
            A value from the System.Data.DataRowState enumeration. Only rows matching the row state are copied to the destination. 
        </param><seealso cref="P:iAnywhere.Data.SQLAnywhere.SABulkCopy.DestinationTableName"/>
        </member>
        <member name="E:iAnywhere.Data.SQLAnywhere.SABulkCopy.SARowsCopied">
            <summary>
            <para>This event occurs every time the number of rows specified by the NotifyAfter property have been processed.</para>
        </summary><remarks>
            <para>The receipt of an SARowsCopied event does not imply that any rows have been sent to the database server or committed. You cannot call the Close method from this event.</para>
        </remarks><seealso cref="P:iAnywhere.Data.SQLAnywhere.SABulkCopy.NotifyAfter"/>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SABulkCopy.BatchSize">
            <summary>
            <para>Gets or sets the number of rows in each batch. At the end of each batch, the rows in the batch are sent to the server.</para>
        </summary><value> The number of rows in each batch. The default is 0.</value><remarks>
            <para>Setting this property to zero causes all the rows to be sent in one batch.</para>
            <para>Setting this property to a value less than zero is an error.</para>
            <para>If this value is changed while a batch is in progress, the current batch completes and any further batches use the new value.</para>
        </remarks>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SABulkCopy.BulkCopyTimeout">
            <summary>
            <para>Gets or sets the number of seconds for the operation to complete before it times out.</para>
        </summary><value> 
        <para>The default value is 30 seconds.</para>
        </value><remarks>
            <para>A value of zero indicates no limit. This should be avoided because it may cause an indefinite wait.</para>
            <para>If the operation times out, then all rows in the current transaction are rolled back and an SAException is raised.</para>
            <para>Setting this property to a value less than zero is an error.</para>
        </remarks>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SABulkCopy.ColumnMappings">
            <summary>
            <para>Returns a collection of SABulkCopyColumnMapping items. Column mappings define the relationships between columns in the data source and columns in the destination. </para>
        </summary><value>By default, it is an empty collection.</value><remarks>
            <para>The property cannot be modified while WriteToServer is executing.</para>
            <para>If ColumnMappings is empty when WriteToServer is executed, then the first column in the source is mapped to the first column in the destination, the second to the second, and so on. This takes place as long as the column types are convertible, there are at least as many destination columns as source columns, and any extra destination columns are nullable.</para>
        </remarks>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SABulkCopy.DestinationTableName">
            <summary>
            <para>Gets or sets the name of the destination table on the server. </para>
        </summary><value>The default value is a null reference. In Visual Basic it is Nothing.</value><remarks>
            <para>If the value is changed while WriteToServer is executing, the change has no effect.</para>
            <para>If the value has not been set before a call to WriteToServer, an InvalidOperationException is raised.</para>
            <para>It is an error to set the value to NULL or the empty string.</para>
        </remarks>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SABulkCopy.NotifyAfter">
            <summary>
            <para>Gets or sets the number of rows to be processed before generating a notification event.</para>
        </summary><value>Zero is returned if the property has not been set.</value><remarks>
            <para>Changes made to NotifyAfter, while executing WriteToServer, do not take effect until after the next notification.</para>
            <para>Setting this property to a value less than zero is an error.</para>
            <para>The values of NotifyAfter and BulkCopyTimeout are mutually exclusive, so the event can fire even if no rows have been sent to the database or committed.</para>
        </remarks><seealso cref="P:iAnywhere.Data.SQLAnywhere.SABulkCopy.BulkCopyTimeout"/>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SABulkCopyColumnMapping">
            <summary>
            <para>Defines the mapping between a column in an SABulkCopy instance's data source and a column in the instance's destination table.</para>
        </summary><remarks>
            <para>The SABulkCopyColumnMapping class is not available in the .NET Compact Framework 2.0.</para>
        </remarks>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SABulkCopyColumnMapping.#ctor">
            <summary>
            <para>Creates a new column mapping, using column ordinals or names to refer to source and destination columns.</para>
        </summary><remarks>
            <para>The SABulkCopyColumnMapping class is not available in the .NET Compact Framework 2.0.</para>
        </remarks>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SABulkCopyColumnMapping.#ctor(System.Int32,System.Int32)">
            <summary>
            <para>Creates a new column mapping, using column ordinals to refer to source and destination columns.</para>
        </summary><remarks>
            <para>The SABulkCopyColumnMapping class is not available in the .NET Compact Framework 2.0.</para>
        </remarks><param name="sourceColumnOrdinal">
            The ordinal position of the source column within the data source. The first column in a data source has ordinal position zero. 
        </param><param name="destinationColumnOrdinal">
            The ordinal position of the destination column within the destination table. The first column in a table has ordinal position zero. 
        </param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SABulkCopyColumnMapping.#ctor(System.Int32,System.String)">
            <summary>
            <para>Creates a new column mapping, using a column ordinal to refer to the source column and a column name to refer to the destination column.</para>
        </summary><remarks>
            <para>The SABulkCopyColumnMapping class is not available in the .NET Compact Framework 2.0.</para>
        </remarks><param name="sourceColumnOrdinal">
            The ordinal position of the source column within the data source. The first column in a data source has ordinal position zero. 
        </param><param name="destinationColumn">
            The name of the destination column within the destination table. 
        </param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SABulkCopyColumnMapping.#ctor(System.String,System.Int32)">
            <summary>
            <para>Creates a new column mapping, using a column name to refer to the source column and a column ordinal to refer to the destination column.</para>
        </summary><remarks>
            <para>The SABulkCopyColumnMapping class is not available in the .NET Compact Framework 2.0.</para>
        </remarks><param name="sourceColumn">
            The name of the source column within the data source. 
        </param><param name="destinationColumnOrdinal">
            The ordinal position of the destination column within the destination table. The first column in a table has ordinal position zero. 
        </param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SABulkCopyColumnMapping.#ctor(System.String,System.String)">
            <summary>
            <para>Creates a new column mapping, using column names to refer to source and destination columns.</para>
        </summary><remarks>
            <para>The SABulkCopyColumnMapping class is not available in the .NET Compact Framework 2.0.</para>
        </remarks><param name="sourceColumn">
            The name of the source column within the data source. 
        </param><param name="destinationColumn">
            The name of the destination column within the destination table. 
        </param>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SABulkCopyColumnMapping.DestinationColumn">
            <summary>
            <para>Gets or sets the name of the column in the destination database table being mapped to.</para>
        </summary><value>A string specifying the name of the column in the destination table or a null reference (Nothing in Visual Basic) if the DestinationOrdinal property has priority.</value><remarks>
            <para>The DestinationColumn property and DestinationOrdinal property are mutually exclusive. The most recently set value takes priority.</para>
            <para>Setting the DestinationColumn property causes the DestinationOrdinal property to be set to -1. Setting the DestinationOrdinal property causes the DestinationColumn property to be set to a null reference (Nothing in Visual Basic).</para>
            <para>It is an error to set DestinationColumn to null or the empty string.</para>
        </remarks><seealso cref="P:iAnywhere.Data.SQLAnywhere.SABulkCopyColumnMapping.DestinationOrdinal"/>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SABulkCopyColumnMapping.DestinationOrdinal">
            <summary>
            <para>Gets or sets the ordinal value of the column in the destination table being mapped to.</para>
        </summary><value>An integer specifying the ordinal of the column being mapped to in the destination table or -1 if the property is not set.</value><remarks>
            <para>The DestinationColumn property and DestinationOrdinal property are mutually exclusive. The most recently set value takes priority.</para>
            <para>Setting the DestinationColumn property causes the DestinationOrdinal property to be set to -1. Setting the DestinationOrdinal property causes the DestinationColumn property to be set to a null reference (Nothing in Visual Basic).</para>
        </remarks><seealso cref="P:iAnywhere.Data.SQLAnywhere.SABulkCopyColumnMapping.DestinationColumn"/>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SABulkCopyColumnMapping.SourceColumn">
            <summary>
            <para>Gets or sets the name of the column being mapped in the data source.</para>
        </summary><value>A string specifying the name of the column in the data source or a null reference (Nothing in Visual Basic) if the SourceOrdinal property has priority.</value><remarks>
            <para>The SourceColumn property and SourceOrdinal property are mutually exclusive. The most recently set value takes priority.</para>
            <para>Setting the SourceColumn property causes the SourceOrdinal property to be set to -1. Setting the SourceOrdinal property causes the SourceColumn property to be set to a null reference (Nothing in Visual Basic).</para>
            <para>It is an error to set SourceColumn to null or the empty string.</para>
        </remarks><seealso cref="P:iAnywhere.Data.SQLAnywhere.SABulkCopyColumnMapping.SourceOrdinal"/>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SABulkCopyColumnMapping.SourceOrdinal">
            <summary>
            <para>Gets or sets ordinal position of the source column within the data source.</para>
        </summary><value>An integer specifying the ordinal of the column in the data source or -1 if the property is not set.</value><remarks>
            <para>The SourceColumn property and SourceOrdinal property are mutually exclusive. The most recently set value takes priority.</para>
            <para>Setting the SourceColumn property causes the SourceOrdinal property to be set to -1. Setting the SourceOrdinal property causes the SourceColumn property to be set to a null reference (Nothing in Visual Basic).</para>
        </remarks><seealso cref="P:iAnywhere.Data.SQLAnywhere.SABulkCopyColumnMapping.SourceColumn"/>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SABulkCopyColumnMappingCollection">
            <summary>
            <para>A collection of SABulkCopyColumnMapping objects that inherits from System.Collections.CollectionBase.</para>
        </summary><remarks>
            <para>The SABulkCopyColumnMappingCollection class is not available in the .NET Compact Framework 2.0.</para>
        </remarks>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SABulkCopyColumnMappingCollection.Add(iAnywhere.Data.SQLAnywhere.SABulkCopyColumnMapping)">
            <summary>
            <para>Adds the specified SABulkCopyColumnMapping object to the collection.</para>
        </summary><remarks>
            <para>The SABulkCopyColumnMappingCollection class is not available in the .NET Compact Framework 2.0.</para>
        </remarks><param name="bulkCopyColumnMapping">
            <para>The SABulkCopyColumnMapping object that describes the mapping to be added to the collection.</para>
        </param><seealso cref="T:iAnywhere.Data.SQLAnywhere.SABulkCopyColumnMapping"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SABulkCopyColumnMappingCollection.Add(System.Int32,System.Int32)">
            <summary>
            <para>Creates a new SABulkCopyColumnMapping object using ordinals to specify both source and destination columns, and adds the mapping to the collection.</para>
        </summary><remarks>
            <para>The SABulkCopyColumnMappingCollection class is not available in the .NET Compact Framework 2.0.</para>
        </remarks><param name="sourceColumnOrdinal">
            The ordinal position of the source column within the data source. 
        </param><param name="destinationColumnOrdinal">
            The ordinal position of the destination column within the destination table. 
        </param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SABulkCopyColumnMappingCollection.Add(System.Int32,System.String)">
            <summary>
            <para>Creates a new SABulkCopyColumnMapping object using a column ordinal to refer to the source column and a column name to refer to the destination column, and adds mapping to the collection.</para>
        </summary><remarks>
            <para>The SABulkCopyColumnMappingCollection class is not available in the .NET Compact Framework 2.0.</para>
        </remarks><param name="sourceColumnOrdinal">
            The ordinal position of the source column within the data source. 
        </param><param name="destinationColumn">
            The name of the destination column within the destination table. 
        </param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SABulkCopyColumnMappingCollection.Add(System.String,System.Int32)">
            <summary>
            <para>Creates a new SABulkCopyColumnMapping object using a column name to refer to the source column and a column ordinal to refer to the destination the column, and adds the mapping to the collection.</para>
            <para>Creates a new column mapping, using column ordinals or names to refer to source and destination columns.</para>
        </summary><remarks>
            <para>The SABulkCopyColumnMappingCollection class is not available in the .NET Compact Framework 2.0.</para>
        </remarks><param name="sourceColumn">
            The name of the source column within the data source. 
        </param><param name="destinationColumnOrdinal">
            The ordinal position of the destination column within the destination table. 
        </param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SABulkCopyColumnMappingCollection.Add(System.String,System.String)">
            <summary>
            <para>Creates a new SABulkCopyColumnMapping object using column names to specify both source and destination columns, and adds the mapping to the collection.</para>
        </summary><remarks>
            <para>The SABulkCopyColumnMappingCollection class is not available in the .NET Compact Framework 2.0.</para>
        </remarks><param name="sourceColumn">
            The name of the source column within the data source. 
        </param><param name="destinationColumn">
            The name of the destination column within the destination table. 
        </param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SABulkCopyColumnMappingCollection.Contains(iAnywhere.Data.SQLAnywhere.SABulkCopyColumnMapping)">
            <summary>
            <para>Gets a value indicating whether a specified SABulkCopyColumnMapping object exists in the collection.</para>
        </summary><param name="value">
            <para>A valid SABulkCopyColumnMapping object.</para>
        </param><returns>
        <para>True if the specified mapping exists in the collection; otherwise, false.</para>
        </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SABulkCopyColumnMappingCollection.CopyTo(iAnywhere.Data.SQLAnywhere.SABulkCopyColumnMapping[],System.Int32)">
            <summary>
            <para>Copies the elements of the SABulkCopyColumnMappingCollection to an array of SABulkCopyColumnMapping items, starting at a particular index.</para>
        </summary><param name="array">
            The one-dimensional SABulkCopyColumnMapping array that is the destination of the elements copied from SABulkCopyColumnMappingCollection. The array must have zero-based indexing. 
        </param><param name="index">
            The zero-based index in the array at which copying begins. 
        </param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SABulkCopyColumnMappingCollection.IndexOf(iAnywhere.Data.SQLAnywhere.SABulkCopyColumnMapping)">
            <summary>
            <para>Gets or sets the index of the specified SABulkCopyColumnMapping object within the collection.</para>
        </summary><param name="value">
            The SABulkCopyColumnMapping object to search for. 
        </param><returns>
        <para>The zero-based index of the column mapping is returned, or -1 is returned if the column mapping is not found in the collection.</para>
        </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SABulkCopyColumnMappingCollection.Remove(iAnywhere.Data.SQLAnywhere.SABulkCopyColumnMapping)">
            <summary>
            <para>Removes the specified SABulkCopyColumnMapping element from the SABulkCopyColumnMappingCollection.</para>
        </summary><param name="value">
            The SABulkCopyColumnMapping object to be removed from the collection. 
        </param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SABulkCopyColumnMappingCollection.RemoveAt(System.Int32)">
            <summary>
            <para>Removes the mapping at the specified index from the collection.</para>
        </summary><param name="index">
            The zero-based index of the SABulkCopyColumnMapping object to be removed from the collection. 
        </param>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SABulkCopyColumnMappingCollection.Item(System.Int32)">
            <summary>
            <para>Gets the SABulkCopyColumnMapping object at the specified index.</para>
        </summary><param name="index">
            The zero-based index of the SABulkCopyColumnMapping object to find. 
        </param><returns>
        <para>An SABulkCopyColumnMapping object is returned.</para>
        </returns>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SABulkCopyOptions">
            <summary>
            <para>A bitwise flag that specifies one or more options to use with an instance of SABulkCopy.</para>
        </summary><remarks>
            <para>The SABulkCopyOptions enumeration is used when you construct an SABulkCopy object to specify how the WriteToServer methods will behave. </para>
            <para>The SABulkCopyOptions class is not available in the .NET Compact Framework 2.0.</para>
            <para>The CheckConstraints and KeepNulls options are not supported.</para>
        </remarks><seealso cref="T:iAnywhere.Data.SQLAnywhere.SABulkCopy"/>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SABulkCopyOptions.Default">
            <summary>
            <para>Specifying only this value causes the default behavior to be used. By default, triggers are enabled.</para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SABulkCopyOptions.DoNotFireTriggers">
            <summary>
            <para>When specified, triggers are not fired. Disabling triggers requires DBA permission. Triggers are disabled for the connection at the start of WriteToServer and the value is restored at the end of the method.</para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SABulkCopyOptions.KeepIdentity">
            <summary>
            <para>When specified, the source values to be copied into an identity column are preserved. By default, new identity values are generated in the destination table.</para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SABulkCopyOptions.TableLock">
            <summary>
            <para>When specified the table is locked using the command LOCK TABLE table_name WITH HOLD IN SHARE MODE. This lock is in place until the connection is closed.</para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SABulkCopyOptions.UseInternalTransaction">
            <summary>
            <para>When specified, each batch of the bulk-copy operation is executed within a transaction. When not specified, transaction aren't used. If you indicate this option and also provide an SATransaction object to the constructor, a System.ArgumentException occurs.</para>
        </summary>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.AsyncCommandType">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.AsyncCommandResult">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SACommand">
            <summary>
            <para>A SQL statement or stored procedure that is executed against a SQL Anywhere database.</para>
        </summary><remarks>
            <para><b>Implements:</b> <see cref="T:System.ICloneable"/></para>
            <para>For more information, see @olink targetdoc="programming" targetptr="accessing-adodotnet-dev"@Accessing and manipulating data@/olink@.</para>
        </remarks>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommand.#ctor">
            <summary>
            <para>Initializes an SACommand object.</para>
        </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommand.#ctor(System.String)">
            <summary>
            <para>Initializes an SACommand object.</para>
        </summary><param name="cmdText">
            The text of the SQL statement or stored procedure. For parameterized statements, use a question mark (?) placeholder to pass parameters. 
        </param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommand.#ctor(System.String,iAnywhere.Data.SQLAnywhere.SAConnection)">
            <summary>
            <para>A SQL statement or stored procedure that is executed against a SQL Anywhere database.</para>
        </summary><param name="cmdText">
            The text of the SQL statement or stored procedure. For parameterized statements, use a question mark (?) placeholder to pass parameters. 
        </param><param name="connection">
            The current connection. 
        </param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommand.#ctor(System.String,iAnywhere.Data.SQLAnywhere.SAConnection,iAnywhere.Data.SQLAnywhere.SATransaction)">
            <summary>
            <para>A SQL statement or stored procedure that is executed against a SQL Anywhere database.</para>
        </summary><param name="cmdText">
            The text of the SQL statement or stored procedure. For parameterized statements, use a question mark (?) placeholder to pass parameters. 
        </param><param name="connection">
            The current connection. 
        </param><param name="transaction">
            The SATransaction object in which the SAConnection executes. 
        </param><seealso cref="T:iAnywhere.Data.SQLAnywhere.SATransaction"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommand.Finalize">
            <summary>
            <para>Destructs an SACommand object.</para>
        </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommand.System#ICloneable#Clone">
            <summary>
            <para>See SqlCommand.Clone at <a href="http://msdn2.microsoft.com/en-us/library/system.data.sqlclient.sqlcommand.clone.aspx"></a>.</para>
        </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommand.Dispose(System.Boolean)">
            <summary>
            <para>Frees the resources associated with the object.</para>
        </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommand.ResetCommandTimeout">
            <summary>
            <para>Resets the CommandTimeout property to its default value of 30 seconds.</para>
        </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommand.CreateDbParameter">
            <summary>
            <para>Creates a new instance of a <see cref="T:System.Data.Common.DbParameter"/> object.</para>
        </summary><returns>
	    <para>A <see cref="T:System.Data.Common.DbParameter"/> object.</para>
        </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommand.CreateParameter">
            <summary>
            <para>Provides an SAParameter object for supplying parameters to SACommand objects.</para>
        </summary><remarks>
            <para>Stored procedures and some other SQL statements can take parameters, indicated in the text of a statement by a question mark (?).</para>
            <para>The CreateParameter method provides an SAParameter object. You can set properties on the SAParameter to specify the value, data type, and so on for the parameter.</para>
        </remarks><returns>
	    <para>A new parameter, as an SAParameter object.</para>
        </returns><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAParameter"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommand.ExecuteDbDataReader(System.Data.CommandBehavior)">
            <summary>
            <para>Executes the command text against the connection.</para>
        </summary><param name="behavior">
            An instance of <see cref="T:System.Data.CommandBehavior"/>. 
        </param><returns>
	    <para>A <see cref="T:System.Data.Common.DbDataReader"/>.</para>
        </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommand.ExecuteReader">
            <summary>
            <para>Executes a SQL statement that returns a result set.</para>
        </summary><remarks>
            <para>The statement is the current SACommand object, with CommandText and Parameters as needed. The SADataReader object is a read-only, forward-only result set. For modifiable result sets, use an SADataAdapter.</para>
        </remarks><returns>
	    <para>The result set as an SADataReader object.</para>
        </returns><seealso cref="M:iAnywhere.Data.SQLAnywhere.SACommand.ExecuteNonQuery"/><seealso cref="T:iAnywhere.Data.SQLAnywhere.SADataReader"/><seealso cref="T:iAnywhere.Data.SQLAnywhere.SADataAdapter"/><seealso cref="P:iAnywhere.Data.SQLAnywhere.SACommand.CommandText"/><seealso cref="P:iAnywhere.Data.SQLAnywhere.SACommand.Parameters"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommand.ExecuteReader(System.Data.CommandBehavior)">
            <summary>
            <para>Executes a SQL statement that returns a result set.</para>
        </summary><remarks>
            <para>The statement is the current SACommand object, with CommandText and Parameters as needed. The SADataReader object is a read-only, forward-only result set. For modifiable result sets, use an SADataAdapter.</para>
        </remarks><param name="behavior">
            One of CloseConnection, Default, KeyInfo, SchemaOnly, SequentialAccess, SingleResult, or SingleRow. 
            For more information about this parameter, see the .NET Framework documentation for CommandBehavior Enumeration.
        </param><returns>
	    <para>The result set as an SADataReader object.</para>
        </returns><seealso cref="M:iAnywhere.Data.SQLAnywhere.SACommand.ExecuteNonQuery"/><seealso cref="T:iAnywhere.Data.SQLAnywhere.SADataReader"/><seealso cref="T:iAnywhere.Data.SQLAnywhere.SADataAdapter"/><seealso cref="P:iAnywhere.Data.SQLAnywhere.SACommand.CommandText"/><seealso cref="P:iAnywhere.Data.SQLAnywhere.SACommand.Parameters"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommand.BeginExecuteReader">
            <summary>
            <para>Initiates the asynchronous execution of a SQL statement or stored procedure that is described by this SACommand, and retrieves one or more result sets from the database server.</para>
        </summary><returns>
	    <para>An <see cref="T:System.IAsyncResult"/> that can be used to poll, wait for results, or both; this value is also needed when invoking EndExecuteReader(IAsyncResult), which returns an SADataReader object that can be used to retrieve the returned rows.</para>
        </returns><exception cref="T:iAnywhere.Data.SQLAnywhere.SAException">
            <para>Any error that occurred while executing the command text.</para>
        </exception><seealso cref="M:iAnywhere.Data.SQLAnywhere.SACommand.EndExecuteReader(System.IAsyncResult)"/><seealso cref="T:iAnywhere.Data.SQLAnywhere.SADataReader"/><remarks>
            <para>For asynchronous command, the order of parameters must be consistent with CommandText.</para>
        </remarks>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommand.BeginExecuteReader(System.Data.CommandBehavior)">
            <summary>
            <para>Initiates the asynchronous execution of a SQL statement or stored procedure that is described by this SACommand, and retrieves one or more result sets from the server.</para>
        </summary><param name="behavior">
            A bitwise combination of <see cref="T:System.Data.CommandBehavior"/> flags describing the results of the query and its effect on the connection. 
        </param><returns>
	    <para>An <see cref="T:System.IAsyncResult"/> that can be used to poll, wait for results, or both; this value is also needed when invoking EndExecuteReader(IAsyncResult), which returns an SADataReader object that can be used to retrieve the returned rows.</para>
        </returns><exception cref="T:iAnywhere.Data.SQLAnywhere.SAException">
            <para>Any error that occurred while executing the command text.</para>
        </exception><seealso cref="M:iAnywhere.Data.SQLAnywhere.SACommand.EndExecuteReader(System.IAsyncResult)"/><seealso cref="T:iAnywhere.Data.SQLAnywhere.SADataReader"/><remarks>
            <para>For asynchronous command, the order of parameters must be consistent with CommandText.</para>
        </remarks>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommand.BeginExecuteReader(System.AsyncCallback,System.Object)">
            <summary>
            <para>Initiates the asynchronous execution of a SQL statement that is described by the SACommand object, and retrieves the result set, given a callback procedure and state information.</para>
        </summary><param name="callback">
            An <see cref="T:System.AsyncCallback"/> delegate that is invoked when the command's execution has completed. Pass null (Nothing in Microsoft Visual Basic) to indicate that no callback is required. 
        </param><param name="stateObject">
            A user-defined state object that is passed to the callback procedure. Retrieve this object from within the callback procedure using the <see cref="P:System.IAsyncResult.AsyncState"/> property. 
        </param><returns>
	    <para>An <see cref="T:System.IAsyncResult"/> that can be used to poll, wait for results, or both; this value is also needed when invoking EndExecuteReader(IAsyncResult), which returns an SADataReader object that can be used to retrieve the returned rows.</para>
        </returns><exception cref="T:iAnywhere.Data.SQLAnywhere.SAException">
            <para>Any error that occurred while executing the command text.</para>
        </exception><seealso cref="M:iAnywhere.Data.SQLAnywhere.SACommand.EndExecuteReader(System.IAsyncResult)"/><seealso cref="T:iAnywhere.Data.SQLAnywhere.SADataReader"/><remarks>
            <para>For asynchronous command, the order of parameters must be consistent with CommandText.</para>
        </remarks>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommand.BeginExecuteReader(System.AsyncCallback,System.Object,System.Data.CommandBehavior)">
            <summary>
            <para>Initiates the asynchronous execution of a SQL statement or stored procedure that is described by this SACommand, and retrieves one or more result sets from the server.</para>
        </summary><param name="callback">
            An <see cref="T:System.AsyncCallback"/> delegate that is invoked when the command's execution has completed. Pass null (Nothing in Microsoft Visual Basic) to indicate that no callback is required. 
        </param><param name="stateObject">
            A user-defined state object that is passed to the callback procedure. Retrieve this object from within the callback procedure using the <see cref="P:System.IAsyncResult.AsyncState"/> property. 
        </param><param name="behavior">
            A bitwise combination of <see cref="T:System.Data.CommandBehavior"/> flags describing the results of the query and its effect on the connection. 
        </param><returns>
	    <para>An <see cref="T:System.IAsyncResult"/> that can be used to poll, wait for results, or both; this value is also needed when invoking EndExecuteReader(IAsyncResult), which returns an SADataReader object that can be used to retrieve the returned rows.</para>
        </returns><exception cref="T:iAnywhere.Data.SQLAnywhere.SAException">
            <para>Any error that occurred while executing the command text.</para>
        </exception><seealso cref="M:iAnywhere.Data.SQLAnywhere.SACommand.EndExecuteReader(System.IAsyncResult)"/><seealso cref="T:iAnywhere.Data.SQLAnywhere.SADataReader"/><remarks>
            <para>For asynchronous command, the order of parameters must be consistent with CommandText.</para>
        </remarks>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommand.EndExecuteReader(System.IAsyncResult)">
            <summary>
            <para>Finishes asynchronous execution of a SQL statement or stored procedure, returning the requested SADataReader.</para>
        </summary><remarks>
            <para>You must call EndExecuteReader once for every call to BeginExecuteReader. The call must be after BeginExecuteReader has returned. ADO.NET is not thread safe; it is your responsibility to ensure that BeginExecuteReader has returned. The IAsyncResult passed to EndExecuteReader must be the same as the one returned from the BeginExecuteReader call that is being completed. It is an error to call EndExecuteReader to end a call to BeginExecuteNonQuery, and vice versa.</para>
            <para>If an error occurs while executing the command, the exception is thrown when EndExecuteReader is called.</para>
            <para>There are four ways to wait for execution to complete:</para>
            <para>(1) Call EndExecuteReader.</para>
	    <para>Calling EndExecuteReader blocks until the command completes. For example:</para>
            <code>SAConnection conn = new SAConnection("DSN=SQL Anywhere 12 Demo");
conn.Open();
SACommand cmd = new SACommand( "SELECT * FROM Departments", conn );
IAsyncResult res = cmd.BeginExecuteReader();
// perform other work
// this blocks until the command completes
SADataReader reader = cmd.EndExecuteReader( res );</code>
            <para>(2) Poll the IsCompleted property of the IAsyncResult.</para>
	    <para> You can poll the IsCompleted property of the IAsyncResult. For example:</para>
            <code>SAConnection conn = new SAConnection("DSN=SQL Anywhere 12 Demo");
conn.Open();
SACommand cmd = new SACommand( "SELECT * FROM Departments", conn );
IAsyncResult res = cmd.BeginExecuteReader();
while( !res.IsCompleted ) {
    // do other work
}
// this does not block because the command is finished
SADataReader reader = cmd.EndExecuteReader( res );</code>
            <para>(3) Use the IAsyncResult.AsyncWaitHandle property to get a synchronization object.</para>
	    <para>You can use the IAsyncResult.AsyncWaitHandle property to get a synchronization object, and wait on that. For example:</para>
            <code>SAConnection conn = new SAConnection("DSN=SQL Anywhere 12 Demo");
conn.Open();
SACommand cmd = new SACommand( "SELECT * FROM Departments", conn );
IAsyncResult res = cmd.BeginExecuteReader();
// perform other work
WaitHandle wh = res.AsyncWaitHandle;
wh.WaitOne();
// this does not block because the command is finished
SADataReader reader = cmd.EndExecuteReader( res );</code>
            <para>(4) Specify a callback function when calling BeginExecuteReader</para>
	    <para>You can specify a callback function when calling BeginExecuteReader. For example:</para>
            <code>private void callbackFunction( IAsyncResult ar ) {
    SACommand cmd = (SACommand) ar.AsyncState;
    // this does not block since the command has completed
    SADataReader reader = cmd.EndExecuteReader();
}

// elsewhere in the code
private void DoStuff() {
    SAConnection conn = new SAConnection("DSN=SQL Anywhere 12 Demo");
    conn.Open();
    SACommand cmd = new SACommand( "SELECT * FROM Departments", conn );
    IAsyncResult res = cmd.BeginExecuteReader( callbackFunction, cmd );
    // perform other work.  The callback function will be 
    // called when the command completes
}</code>
            <para>The callback function executes in a separate thread, so the usual caveats related to updating the user interface in a threaded program apply.</para>




        </remarks><param name="asyncResult">
            The IAsyncResult returned by the call to SACommand.BeginExecuteReader. 
        </param><returns>
	    <para>An SADataReader object that can be used to retrieve the requested rows (the same behavior as SACommand.ExecuteReader).</para>
        </returns><exception cref="T:System.ArgumentException">
            <para>The asyncResult parameter is null (Nothing in Microsoft Visual Basic)</para>
        </exception><exception cref="T:System.InvalidOperationException">
            <para>The SACommand.EndExecuteReader(IAsyncResult) was called more than once for a single command execution, or the method was mismatched against its execution method.</para>
        </exception><seealso cref="M:iAnywhere.Data.SQLAnywhere.SACommand.BeginExecuteReader"/><seealso cref="T:iAnywhere.Data.SQLAnywhere.SADataReader"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommand.Prepare">
            <summary>
            <para>Prepares or compiles the SACommand on the data source.</para>
        </summary><remarks>
            <para>If you call one of the ExecuteNonQuery, ExecuteReader, or ExecuteScalar methods after calling Prepare, any parameter value that is larger than the value specified by the Size property is automatically truncated to the original specified size of the parameter, and no truncation errors are returned.</para>
            <para>The truncation only happens for the following data types:</para>
            <list>
            <item>
            <term>CHAR</term> 
            </item>
            <item>
            <term>VARCHAR</term> 
            </item>
            <item>
            <term>LONG VARCHAR</term> 
            </item>
            <item>
            <term>TEXT</term> 
            </item>
            <item>
            <term>NCHAR</term> 
            </item>
            <item>
            <term>NVARCHAR</term> 
            </item>
            <item>
            <term>LONG NVARCHAR</term> 
            </item>
            <item>
            <term>NTEXT</term> 
            </item>
            <item>
            <term>BINARY</term> 
            </item>
            <item>
            <term>LONG BINARY</term> 
            </item>
            <item>
            <term>VARBINARY</term> 
            </item>
            <item>
            <term>IMAGE</term> 
            </item>
            </list>
            <para>If the size property is not specified, and so is using the default value, the data is not truncated.</para>
        </remarks><seealso cref="M:iAnywhere.Data.SQLAnywhere.SACommand.ExecuteNonQuery"/><seealso cref="M:iAnywhere.Data.SQLAnywhere.SACommand.ExecuteReader"/><seealso cref="M:iAnywhere.Data.SQLAnywhere.SACommand.ExecuteScalar"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommand.ExecuteNonQuery">
            <summary>
            <para>Executes a statement that does not return a result set, such as an INSERT, UPDATE, DELETE, or data definition statement.</para>
        </summary><remarks>
            <para>You can use ExecuteNonQuery to change the data in a database without using a DataSet. Do this by executing UPDATE, INSERT, or DELETE statements.</para>
            <para>Although ExecuteNonQuery does not return any rows, output parameters or return values that are mapped to parameters are populated with data.</para>
            <para>For UPDATE, INSERT, and DELETE statements, the return value is the number of rows affected by the command. For all other types of statements, and for rollbacks, the return value is -1.</para>
        </remarks><returns>
	    <para>The number of rows affected.</para>
        </returns><seealso cref="M:iAnywhere.Data.SQLAnywhere.SACommand.ExecuteReader"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommand.BeginExecuteNonQuery">
            <summary>
            <para>Initiates the asynchronous execution of a SQL statement or stored procedure that is described by this SACommand.</para>
        </summary><returns>
	    <para>An <see cref="T:System.IAsyncResult"/> that can be used to poll, wait for results, or both; this value is also needed when invoking EndExecuteNonQuery(IAsyncResult), which returns the number of affected rows.</para>
        </returns><exception cref="T:iAnywhere.Data.SQLAnywhere.SAException">
            <para>Any error that occurred while executing the command text.</para>
        </exception><seealso cref="M:iAnywhere.Data.SQLAnywhere.SACommand.EndExecuteNonQuery(System.IAsyncResult)"/><remarks>
            <para>For asynchronous command, the order of parameters must be consistent with CommandText.</para>
        </remarks>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommand.BeginExecuteNonQuery(System.AsyncCallback,System.Object)">
            <summary>
            <para>Initiates the asynchronous execution of a SQL statement or stored procedure that is described by this SACommand, given a callback procedure and state information.</para>
        </summary><param name="callback">
            An <see cref="T:System.AsyncCallback"/> delegate that is invoked when the command's execution has completed. Pass null (Nothing in Microsoft Visual Basic) to indicate that no callback is required. 
        </param><param name="stateObject">
            A user-defined state object that is passed to the callback procedure. Retrieve this object from within the callback procedure using the <see cref="P:System.IAsyncResult.AsyncState"/> property. 
        </param><returns>
	    <para>An <see cref="T:System.IAsyncResult"/> that can be used to poll, wait for results, or both; this value is also needed when invoking EndExecuteNonQuery(IAsyncResult), which returns the number of affected rows.</para>
        </returns><exception cref="T:iAnywhere.Data.SQLAnywhere.SAException">
            <para>Any error that occurred while executing the command text.</para>
        </exception><seealso cref="M:iAnywhere.Data.SQLAnywhere.SACommand.EndExecuteNonQuery(System.IAsyncResult)"/><remarks>
            <para>For asynchronous command, the order of parameters must be consistent with CommandText.</para>
        </remarks>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommand.EndExecuteNonQuery(System.IAsyncResult)">
            <summary>
            <para>Finishes asynchronous execution of a SQL statement or stored procedure.</para>
        </summary><remarks>
            <para>You must call EndExecuteNonQuery once for every call to BeginExecuteNonQuery. The call must be after BeginExecuteNonQuery has returned. ADO.NET is not thread safe; it is your responsibility to ensure that BeginExecuteNonQuery has returned. The IAsyncResult passed to EndExecuteNonQuery must be the same as the one returned from the BeginExecuteNonQuery call that is being completed. It is an error to call EndExecuteNonQuery to end a call to BeginExecuteReader, and vice versa.</para>
            <para>If an error occurs while executing the command, the exception is thrown when EndExecuteNonQuery is called.</para>
            <para>There are four ways to wait for execution to complete:</para>
            <para>(1) Call EndExecuteNonQuery.</para>
	    <para>Calling EndExecuteNonQuery blocks until the command completes. For example:</para>
            <code>SAConnection conn = new SAConnection("DSN=SQL Anywhere 12 Demo");
conn.Open();
SACommand cmd = new SACommand( 
    "UPDATE Departments"
        + " SET DepartmentName = 'Engineering'"
        + " WHERE DepartmentID=100",
    conn );
IAsyncResult res = cmd.BeginExecuteNonQuery();
// perform other work
// this will block until the command completes
int rowCount reader = cmd.EndExecuteNonQuery( res );</code>
            <para>(2) Poll the IsCompleted property of the IAsyncResult.</para>
	    <para>You can poll the IsCompleted property of the IAsyncResult. For example:</para>
            <code>SAConnection conn = new SAConnection("DSN=SQL Anywhere 12 Demo");
conn.Open();
SACommand cmd = new SACommand( 
    "UPDATE Departments"
        + " SET DepartmentName = 'Engineering'"
        + " WHERE DepartmentID=100",
    conn );
IAsyncResult res = cmd.BeginExecuteNonQuery();
while( !res.IsCompleted ) {
    // do other work
}
// this will not block because the command is finished
int rowCount = cmd.EndExecuteNonQuery( res );</code>
            <para>(3) Use the IAsyncResult.AsyncWaitHandle property to get a synchronization object.</para>
	    <para>You can use the IAsyncResult.AsyncWaitHandle property to get a synchronization object, and wait on that. For example:</para>
            <code>SAConnection conn = new SAConnection("DSN=SQL Anywhere 12 Demo");
conn.Open();
SACommand cmd = new SACommand( 
    "UPDATE Departments"
        + " SET DepartmentName = 'Engineering'"
        + " WHERE DepartmentID=100",
    conn );
IAsyncResult res = cmd.BeginExecuteNonQuery();
// perform other work
WaitHandle wh = res.AsyncWaitHandle;
wh.WaitOne();
// this will not block because the command is finished
int rowCount = cmd.EndExecuteNonQuery( res );</code>
            <para>(4) Specify a callback function when calling BeginExecuteNonQuery.</para>
	    <para>You can specify a callback function when calling BeginExecuteNonQuery. For example:</para>
            <code>private void callbackFunction( IAsyncResult ar ) {
    SACommand cmd = (SACommand) ar.AsyncState;
    // this won't block since the command has completed
    int rowCount = cmd.EndExecuteNonQuery();
}

// elsewhere in the code
private void DoStuff() {
    SAConnection conn = new SAConnection("DSN=SQL Anywhere 12 Demo");
    conn.Open();
    SACommand cmd = new SACommand(
        "UPDATE Departments"
            + " SET DepartmentName = 'Engineering'"
            + " WHERE DepartmentID=100",
        conn );
    IAsyncResult res = cmd.BeginExecuteNonQuery( callbackFunction, cmd );
    // perform other work.  The callback function will be 
    // called when the command completes
}</code>
            <para>The callback function executes in a separate thread, so the usual caveats related to updating the user interface in a threaded program apply.</para>




        </remarks><param name="asyncResult">
            The IAsyncResult returned by the call to SACommand.BeginExecuteNonQuery. 
        </param><returns>
	    <para>The number of rows affected (the same behavior as SACommand.ExecuteNonQuery).</para>
        </returns><exception cref="T:System.ArgumentException">
            <para>The asyncResult parameter is null (Nothing in Microsoft Visual Basic).</para>
        </exception><exception cref="T:System.InvalidOperationException">
            <para>The SACommand.EndExecuteNonQuery(IAsyncResult) was called more than once for a single command execution, or the method was mismatched against its execution method.</para>
        </exception><seealso cref="M:iAnywhere.Data.SQLAnywhere.SACommand.BeginExecuteNonQuery"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommand.ExecuteScalar">
            <summary>
            <para>Executes a statement that returns a single value. If this method is called on a query that returns multiple rows and columns, only the first column of the first row is returned.</para>
        </summary><returns>
	    <para>The first column of the first row in the result set, or a null reference if the result set is empty.</para>
        </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommand.Cancel">
            <summary>
            <para>Cancels the execution of an SACommand object.</para>
        </summary><remarks>
            <para>If there is nothing to cancel, nothing happens. If there is a command in process, a "Statement interrupted by user" exception is thrown.</para>
        </remarks>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SACommand.CommandText">
            <summary>
            <para>Gets or sets the text of a SQL statement or stored procedure.</para>
        </summary><value>The SQL statement or the name of the stored procedure to execute. The default is an empty string.</value><seealso cref="M:iAnywhere.Data.SQLAnywhere.SACommand.#ctor"/>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SACommand.CommandTimeout">
            <summary>
            <para>This feature is not supported by the SQL Anywhere .NET Data Provider. See the following example to set a request timeout:</para>
	    <code>cmd.CommandText = "SET OPTION request_timeout = 30";
    cmd.ExecuteNonQuery();</code>
        </summary>	
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SACommand.CommandType">
            <summary>
            <para>Gets or sets the type of command represented by an SACommand.</para>
        </summary><value>One of the <see cref="T:System.Data.CommandType"/> values. The default is <see cref="F:System.Data.CommandType.Text"/>.</value><remarks>
            <para>Supported command types are as follows: </para>
            <list type="bullet">
            <item>
            <term><see cref="F:System.Data.CommandType.StoredProcedure"/></term> When you specify this CommandType, the command text must be the name of a stored procedure and you must supply any arguments as SAParameter objects. 
            </item>
            <item>
            <term><see cref="F:System.Data.CommandType.Text"/></term> This is the default value. 
            </item>
            </list>
            <para>When the CommandType property is set to StoredProcedure, the CommandText property should be set to the name of the stored procedure. The command executes this stored procedure when you call one of the Execute methods.</para>
            <para>Use a question mark (?) placeholder to pass parameters. For example:</para>
            <code>SELECT * FROM Customers WHERE ID = ?</code>
            <para>The order in which SAParameter objects are added to the SAParameterCollection must directly correspond to the position of the question mark placeholder for the parameter.</para>

        </remarks>	
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SACommand.DbConnection">
            <summary>
            <para>Gets or sets the <see cref="T:System.Data.Common.DbConnection"/> used by this SACommand object.</para>
        </summary><returns>
	    <para>The connection to the data source.</para>
        </returns><seealso cref="T:iAnywhere.Data.SQLAnywhere.SACommand"/>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SACommand.Connection">
            <summary>
            <para>Gets or sets the connection object to which the SACommand object applies.</para>
        </summary><value>The default value is a null reference. In Visual Basic it is Nothing.</value>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SACommand.DesignTimeVisible">
            <summary>
            <para>Gets or sets a value that indicates if the SACommand should be visible in a Windows Form Designer control. The default is true.</para>
        </summary><value>True if this SACommand instance should be visible, false if this instance should not be visible. The default is false.</value>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SACommand.DbParameterCollection">
            <summary>
            <para>Gets the collection of <see cref="T:System.Data.Common.DbParameter"/> objects.</para>
        </summary><returns>
	    <para>The parameters of the SQL statement or stored procedure.</para>
        </returns>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SACommand.Parameters">
            <summary>
            <para>A collection of parameters for the current statement. Use question marks in the CommandText to indicate parameters.</para>
        </summary><value>The parameters of the SQL statement or stored procedure. The default value is an empty collection.</value><remarks>
            <para>When CommandType is set to Text, pass parameters using the question mark placeholder. For example:</para>
            <code>SELECT * FROM Customers WHERE ID = ?</code>
            <para>The order in which SAParameter objects are added to the SAParameterCollection must directly correspond to the position of the question mark placeholder for the parameter in the command text.</para>
            <para>When the parameters in the collection do not match the requirements of the query to be executed, an error may result or an exception may be thrown.</para>

        </remarks><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAParameterCollection"/>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SACommand.DbTransaction">
            <summary>
            <para>Gets or sets the <see cref="T:System.Data.Common.DbTransaction"/> within which this SACommand object executes.</para>
        </summary><returns>
	    <para>The transaction within which a Command object of a .NET Framework data provider executes. The default value is a null reference (Nothing in Visual Basic).</para>
        </returns>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SACommand.Transaction">
            <summary>
            <para>Specifies the SATransaction object in which the SACommand executes.</para>
        </summary><value>The default value is a null reference. In Visual Basic, this is Nothing.</value><remarks>
            <para>You cannot set the Transaction property if it is already set to a specific value and the command is executing. If you set the transaction property to an SATransaction object that is not connected to the same SAConnection object as the SACommand object, an exception will be thrown the next time you attempt to execute a statement.</para>
            <para>For more information, see @olink targetdoc="programming" targetptr="transaction-adodotnet-development"@Transaction processing@/olink@.</para>
        </remarks><seealso cref="T:iAnywhere.Data.SQLAnywhere.SATransaction"/>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SACommand.UpdatedRowSource">
            <summary>
            <para>Gets or sets how command results are applied to the DataRow when used by the Update method of the SADataAdapter.</para>
        </summary><value> 
	<para>One of the UpdatedRowSource values. The default value is UpdateRowSource.OutputParameters. If the command is automatically generated, this property is UpdateRowSource.None.</para>
        </value><remarks>
	    <para>UpdatedRowSource.Both, which returns both resultset and output parameters, is not supported.</para>
	</remarks>	
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SACommandBuilder">
            <summary>
            <para>A way to generate single-table SQL statements that reconcile changes made to a DataSet with the data in the associated database.</para>
        </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommandBuilder.#ctor">
            <summary>
            <para>Initializes an SACommandBuilder object.</para>
        </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommandBuilder.#ctor(iAnywhere.Data.SQLAnywhere.SADataAdapter)">
            <summary>
            <para>Initializes an SACommandBuilder object.</para>
        </summary><remarks>
        </remarks><param name="adapter">
            An SADataAdapter object for which to generate reconciliation statements. 
        </param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommandBuilder.GetInsertCommand(System.Boolean)">
            <summary>
            <para>Returns the generated SACommand object that performs INSERT operations on the database when an Update is called.</para>
        </summary><remarks>
            <para>The GetInsertCommand method returns the SACommand object to be executed, so it may be useful for informational or troubleshooting purposes.</para>
            <para>You can also use GetInsertCommand as the basis of a modified command. For example, you might call GetInsertCommand and modify the CommandTimeout value, and then explicitly set that value on the SADataAdapter.</para>
            <para>SQL statements are first generated either when the application calls Update or GetInsertCommand. After the SQL statement is first generated, the application must explicitly call RefreshSchema if it changes the statement in any way. Otherwise, the GetInsertCommand will be still be using information from the previous statement, which might not be correct.</para>
        </remarks><param name="useColumnsForParameterNames">
            If true, generate parameter names matching column names if possible. If false, generate @p1, @p2, and so on. 
        </param><returns>
	    <para>The automatically generated SACommand object required to perform insertions.</para>
        </returns><seealso cref="M:iAnywhere.Data.SQLAnywhere.SACommandBuilder.GetDeleteCommand"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommandBuilder.GetInsertCommand">
            <summary>
            <para>Returns the generated SACommand object that performs INSERT operations on the database when an Update is called.</para>
        </summary><remarks>
            <para>The GetInsertCommand method returns the SACommand object to be executed, so it may be useful for informational or troubleshooting purposes.</para>
            <para>You can also use GetInsertCommand as the basis of a modified command. For example, you might call GetInsertCommand and modify the CommandTimeout value, and then explicitly set that value on the SADataAdapter.</para>
            <para>SQL statements are first generated either when the application calls Update or GetInsertCommand. After the SQL statement is first generated, the application must explicitly call RefreshSchema if it changes the statement in any way. Otherwise, the GetInsertCommand will be still be using information from the previous statement, which might not be correct.</para>
        </remarks><returns>
	    <para>The automatically generated SACommand object required to perform insertions.</para>
        </returns><seealso cref="M:iAnywhere.Data.SQLAnywhere.SACommandBuilder.GetDeleteCommand"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommandBuilder.GetDeleteCommand(System.Boolean)">
            <summary>
            <para>Returns the generated SACommand object that performs DELETE operations on the database when SADataAdapter.Update is called.</para>
        </summary><remarks>
            <para>The GetDeleteCommand method returns the SACommand object to be executed, so it may be useful for informational or troubleshooting purposes.</para>
            <para>You can also use GetDeleteCommand as the basis of a modified command. For example, you might call GetDeleteCommand and modify the CommandTimeout value, and then explicitly set that value on the SADataAdapter.</para>
            <para>SQL statements are first generated when the application calls Update or GetDeleteCommand. After the SQL statement is first generated, the application must explicitly call RefreshSchema if it changes the statement in any way. Otherwise, the GetDeleteCommand will still be using information from the previous statement.</para>
        </remarks><param name="useColumnsForParameterNames">
            If true, generate parameter names matching column names if possible. If false, generate @p1, @p2, and so on. 
        </param><returns>
	    <para>The automatically generated SACommand object required to perform deletions.</para>
        </returns><seealso cref="M:System.Data.Common.DbCommandBuilder.RefreshSchema"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommandBuilder.GetDeleteCommand">
            <summary>
            <para>Returns the generated SACommand object that performs DELETE operations on the database when SADataAdapter.Update is called.</para>
        </summary><remarks>
            <para>The GetDeleteCommand method returns the SACommand object to be executed, so it may be useful for informational or troubleshooting purposes.</para>
            <para>You can also use GetDeleteCommand as the basis of a modified command. For example, you might call GetDeleteCommand and modify the CommandTimeout value, and then explicitly set that value on the SADataAdapter.</para>
            <para>SQL statements are first generated when the application calls Update or GetDeleteCommand. After the SQL statement is first generated, the application must explicitly call RefreshSchema if it changes the statement in any way. Otherwise, the GetDeleteCommand will still be using information from the previous statement.</para>
        </remarks><returns>
	    <para>The automatically generated SACommand object required to perform deletions.</para>
        </returns><seealso cref="M:System.Data.Common.DbCommandBuilder.RefreshSchema"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommandBuilder.GetUpdateCommand(System.Boolean)">
            <summary>
            <para>Returns the generated SACommand object that performs UPDATE operations on the database when an Update is called.</para>
        </summary><remarks>
            <para>The GetUpdateCommand method returns the SACommand object to be executed, so it may be useful for informational or troubleshooting purposes.</para>
            <para>You can also use GetUpdateCommand as the basis of a modified command. For example, you might call GetUpdateCommand and modify the CommandTimeout value, and then explicitly set that value on the SADataAdapter.</para>
            <para>SQL statements are first generated when the application calls Update or GetUpdateCommand. After the SQL statement is first generated, the application must explicitly call RefreshSchema if it changes the statement in any way. Otherwise, the GetUpdateCommand will be still be using information from the previous statement, which might not be correct.</para>
        </remarks><param name="useColumnsForParameterNames">
            If true, generate parameter names matching column names if possible. If false, generate @p1, @p2, and so on. 
        </param><returns>
	    <para>The automatically generated SACommand object required to perform updates.</para>
        </returns><seealso cref="M:System.Data.Common.DbCommandBuilder.RefreshSchema"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommandBuilder.GetUpdateCommand">
            <summary>
            <para>Returns the generated SACommand object that performs UPDATE operations on the database when an Update is called.</para>
        </summary><remarks>
            <para>The GetUpdateCommand method returns the SACommand object to be executed, so it may be useful for informational or troubleshooting purposes.</para>
            <para>You can also use GetUpdateCommand as the basis of a modified command. For example, you might call GetUpdateCommand and modify the CommandTimeout value, and then explicitly set that value on the SADataAdapter.</para>
            <para>SQL statements are first generated when the application calls Update or GetUpdateCommand. After the SQL statement is first generated, the application must explicitly call RefreshSchema if it changes the statement in any way. Otherwise, the GetUpdateCommand will be still be using information from the previous statement, which might not be correct.</para>
        </remarks><returns>
	    <para>The automatically generated SACommand object required to perform updates.</para>
        </returns><seealso cref="M:System.Data.Common.DbCommandBuilder.RefreshSchema"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommandBuilder.ApplyParameterInfo(System.Data.Common.DbParameter,System.Data.DataRow,System.Data.StatementType,System.Boolean)">
            <summary>
            <para>Allows the provider implementation of <see cref="T:System.Data.Common.DbCommandBuilder"/> to handle additional parameter properties.</para>
        </summary><param name="parameter">
            A <see cref="T:System.Data.Common.DbParameter"/> to which the additional modifications are applied. 
        </param><param name="row">
            The <see cref="T:System.Data.DataRow"/> from the schema table provided by SADataReader.GetSchemaTable. 
        </param><param name="statementType">
            The type of command being generated: INSERT, UPDATE or DELETE. 
        </param><param name="whereClause">
            The value is true if the parameter is part of the UPDATE or DELETE WHERE clause, and false if it is part of the INSERT or UPDATE values. 
        </param><seealso cref="M:iAnywhere.Data.SQLAnywhere.SADataReader.GetSchemaTable"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommandBuilder.GetSchemaTable(System.Data.Common.DbCommand)">
            <summary>
            <para>Returns the schema table for the SACommandBuilder object.</para>
        </summary><param name="sourceCommand">
            The <see cref="T:System.Data.Common.DbCommand"/> for which to retrieve the corresponding schema table. 
        </param><returns>
	    <para>A <see cref="T:System.Data.DataTable"/> that represents the schema for the specific <see cref="T:System.Data.Common.DbCommand"/>.</para>
        </returns><seealso cref="T:iAnywhere.Data.SQLAnywhere.SACommandBuilder"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommandBuilder.InitializeCommand(System.Data.Common.DbCommand)">
            <summary>
            <para>Resets the <see cref="P:System.Data.Common.DbCommand.CommandTimeout"/>, <see cref="P:System.Data.Common.DbCommand.Transaction"/>, <see cref="P:System.Data.Common.DbCommand.CommandType"/>, and <see cref="P:System.Data.Common.DbCommand.UpdatedRowSource"/> properties on the <see cref="T:System.Data.Common.DbCommand"/>.</para>
        </summary><param name="command">
            The <see cref="T:System.Data.Common.DbCommand"/> to be used by the command builder for the corresponding insert, update, or delete command. 
        </param><returns>
	    <para>A <see cref="T:System.Data.Common.DbCommand"/> instance to use for each insert, update, or delete operation. Passing a null value allows the InitializeCommand method to create a <see cref="T:System.Data.Common.DbCommand"/> object based on the SELECT statement associated with the SACommandBuilder object.</para>
        </returns><seealso cref="T:iAnywhere.Data.SQLAnywhere.SACommandBuilder"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommandBuilder.GetParameterName(System.Int32)">
            <summary>
            <para>Returns the name of the specified parameter in the format of @p#. Use when building a custom command builder.</para>
        </summary><param name="index">
            The number to be included as part of the parameter's name. 
        </param><returns>
	    <para>The name of the parameter with the specified number appended as part of the parameter name.</para>
        </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommandBuilder.GetParameterName(System.String)">
            <summary>
            <para>Returns the full parameter name, given the partial parameter name.</para>
        </summary><param name="parameterName">
            The partial name of the parameter. 
        </param><returns>
	    <para>The full parameter name corresponding to the partial parameter name requested.</para>
        </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommandBuilder.GetParameterPlaceholder(System.Int32)">
            <summary>
            <para>Returns the placeholder for the parameter in the associated SQL statement.</para>
        </summary><param name="index">
            The number to be included as part of the parameter's name. 
        </param><returns>
	    <para>The name of the parameter with the specified number appended.</para>
        </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommandBuilder.SetRowUpdatingHandler(System.Data.Common.DbDataAdapter)">
            <summary>
            <para>Registers the SACommandBuilder object to handle the SADataAdapter.RowUpdating event for an SADataAdapter object.</para>
        </summary><param name="adapter">
            The SADataAdapter object to be used for the update. 
        </param><seealso cref="T:iAnywhere.Data.SQLAnywhere.SACommandBuilder"/><seealso cref="T:iAnywhere.Data.SQLAnywhere.SADataAdapter"/><seealso cref="E:iAnywhere.Data.SQLAnywhere.SADataAdapter.RowUpdating"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommandBuilder.DeriveParameters(iAnywhere.Data.SQLAnywhere.SACommand)">
            <summary>
            <para>Populates the Parameters collection of the specified SACommand object. This is used for the stored procedure specified in the SACommand.</para>
        </summary><remarks>
            <para>DeriveParameters overwrites any existing parameter information for the SACommand.</para>
            <para>DeriveParameters requires an extra call to the database server. If the parameter information is known in advance, it is more efficient to populate the Parameters collection by setting the information explicitly.</para>
        </remarks><param name="command">
            An SACommand object for which to derive parameters. 
        </param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommandBuilder.QuoteIdentifier(System.String)">
            <summary>
			<para>Returns the correct quoted form of an unquoted identifier, including properly escaping any embedded quotes in the identifier.</para>
		</summary><param name="unquotedIdentifier">
			The string representing the unquoted identifier that will have be quoted.
		</param><returns>
			<para>Returns a string representing the quoted form of an unquoted identifier with embedded quotes properly escaped.</para>
		</returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommandBuilder.UnquoteIdentifier(System.String)">
            <summary>
            <para>Returns the correct unquoted form of a quoted identifier, including properly un-escaping any embedded quotes in the identifier.</para>
        </summary><param name="quotedIdentifier">
            The string representing the quoted identifier that will have its embedded quotes removed.
        </param><returns>
	    <para>Returns a string representing the unquoted form of a quoted identifier with embedded quotes properly un-escaped.</para>
        </returns>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SACommandBuilder.DataAdapter">
            <summary>
            <para>Specifies the SADataAdapter for which to generate statements.</para>
        </summary><value>An SADataAdapter object.</value><remarks>
            <para>When you create a new instance of SACommandBuilder, any existing SACommandBuilder that is associated with this SADataAdapter is released.</para>
        </remarks>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SAMetaDataCollectionNames">
            <summary>
            <para>Provides a list of constants for use with the SAConnection.GetSchema(string) method to retrieve metadata collections.</para>
        </summary><remarks>
            <para>This field is constant and read-only.</para>
        </remarks><seealso cref="M:iAnywhere.Data.SQLAnywhere.SAConnection.GetSchema(System.String)"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAMetaDataCollectionNames.#cctor">
            <summary>
            <para>Initializes an SAMetaDataCollectionNames object.</para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SAMetaDataCollectionNames.Columns">
            <summary>
            <para>Provides a constant for use with the SAConnection.GetSchema(string) method that represents the Columns collection.</para>
        </summary><example>
            <para>The following code fills a DataTable with the Columns collection.</para>
            <code>DataTable schema = GetSchema( SAMetaDataCollectionNames.Columns );</code>
        </example><seealso cref="M:iAnywhere.Data.SQLAnywhere.SAConnection.GetSchema(System.String)"/>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SAMetaDataCollectionNames.DataSourceInformation">
            <summary>
            <para>Provides a constant for use with the SAConnection.GetSchema(string) method that represents the DataSourceInformation collection.</para>
        </summary><example>
            <para>The following code fills a DataTable with the DataSourceInformation collection.</para>
            <code>DataTable schema = 
    GetSchema( SAMetaDataCollectionNames.DataSourceInformation );</code>
        </example><seealso cref="M:iAnywhere.Data.SQLAnywhere.SAConnection.GetSchema(System.String)"/>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SAMetaDataCollectionNames.DataTypes">
            <summary>
            <para>Provides a constant for use with the SAConnection.GetSchema(string) method that represents the DataTypes collection.</para>
        </summary><example>
            <para>The following code fills a DataTable with the DataTypes collection.</para>
            <code>DataTable schema = GetSchema( SAMetaDataCollectionNames.DataTypes );</code>
        </example><seealso cref="M:iAnywhere.Data.SQLAnywhere.SAConnection.GetSchema(System.String)"/>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SAMetaDataCollectionNames.ForeignKeys">
            <summary>
            <para>Provides a constant for use with the SAConnection.GetSchema(string) method that represents the ForeignKeys collection.</para>
        </summary><example>
            <para>The following code fills a DataTable with the ForeignKeys collection.</para>
            <code>DataTable schema = GetSchema( SAMetaDataCollectionNames.ForeignKeys );</code>
        </example><seealso cref="M:iAnywhere.Data.SQLAnywhere.SAConnection.GetSchema(System.String)"/>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SAMetaDataCollectionNames.IndexColumns">
            <summary>
            <para>Provides a constant for use with the SAConnection.GetSchema(string) method that represents the IndexColumns collection.</para>
        </summary><example>
            <para>The following code fills a DataTable with the IndexColumns collection.</para>
            <code>DataTable schema = GetSchema( SAMetaDataCollectionNames.IndexColumns );</code>
        </example><seealso cref="M:iAnywhere.Data.SQLAnywhere.SAConnection.GetSchema(System.String)"/>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SAMetaDataCollectionNames.Indexes">
            <summary>
            <para>Provides a constant for use with the SAConnection.GetSchema(string) method that represents the Indexes collection.</para>
        </summary><example>
            <para>The following code fills a DataTable with the Indexes collection.</para>
            <code>DataTable schema = GetSchema( SAMetaDataCollectionNames.Indexes );</code>
        </example><seealso cref="M:iAnywhere.Data.SQLAnywhere.SAConnection.GetSchema(System.String)"/>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SAMetaDataCollectionNames.MetaDataCollections">
            <summary>
            <para>Provides a constant for use with the SAConnection.GetSchema(string) method that represents the MetaDataCollections collection.</para>
        </summary><example>
            <para>The following code fills a DataTable with the MetaDataCollections collection.</para>
            <code>DataTable schema = 
    GetSchema( SAMetaDataCollectionNames.MetaDataCollections );</code>
        </example><seealso cref="M:iAnywhere.Data.SQLAnywhere.SAConnection.GetSchema(System.String)"/>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SAMetaDataCollectionNames.ProcedureParameters">
            <summary>
            <para>Provides a constant for use with the SAConnection.GetSchema(string) method that represents the ProcedureParameters collection.</para>
        </summary><example>
            <para>The following code fills a DataTable with the ProcedureParameters collection.</para>
            <code>DataTable schema = 
    GetSchema( SAMetaDataCollectionNames.ProcedureParameters );</code>
        </example><seealso cref="M:iAnywhere.Data.SQLAnywhere.SAConnection.GetSchema(System.String)"/>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SAMetaDataCollectionNames.Procedures">
            <summary>
            <para>Provides a constant for use with the SAConnection.GetSchema(string) method that represents the Procedures collection.</para>
        </summary><example>
            <para>The following code fills a DataTable with the Procedures collection.</para>
            <code>DataTable schema = GetSchema( SAMetaDataCollectionNames.Procedures );</code>
        </example><seealso cref="M:iAnywhere.Data.SQLAnywhere.SAConnection.GetSchema(System.String)"/>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SAMetaDataCollectionNames.ReservedWords">
            <summary>
            <para>Provides a constant for use with the SAConnection.GetSchema(string) method that represents the ReservedWords collection.</para>
        </summary><example>
            <para>The following code fills a DataTable with the ReservedWords collection.</para>
            <code>DataTable schema = GetSchema( SAMetaDataCollectionNames.ReservedWords );</code>
        </example><seealso cref="M:iAnywhere.Data.SQLAnywhere.SAConnection.GetSchema(System.String)"/>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SAMetaDataCollectionNames.Restrictions">
            <summary>
            <para>Provides a constant for use with the SAConnection.GetSchema(string) method that represents the Restrictions collection.</para>
        </summary><example>
            <para>The following code fills a DataTable with the Restrictions collection.</para>
            <code>DataTable schema = GetSchema( SAMetaDataCollectionNames.Restrictions );</code>
        </example><seealso cref="M:iAnywhere.Data.SQLAnywhere.SAConnection.GetSchema(System.String)"/>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SAMetaDataCollectionNames.Tables">
            <summary>
            <para>Provides a constant for use with the SAConnection.GetSchema(string) method that represents the Tables collection.</para>
        </summary><example>
            <para>The following code fills a DataTable with the Tables collection.</para>
            <code>DataTable schema = GetSchema( SAMetaDataCollectionNames.Tables );</code>
        </example><seealso cref="M:iAnywhere.Data.SQLAnywhere.SAConnection.GetSchema(System.String)"/>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SAMetaDataCollectionNames.Users">
            <summary>
            <para>Provides a constant for use with the SAConnection.GetSchema(string) method that represents the Users collection.</para>
        </summary><example>
            <para>The following code fills a DataTable with the Users collection.</para>
            <code>DataTable schema = GetSchema( SAMetaDataCollectionNames.Users );</code>
        </example><seealso cref="M:iAnywhere.Data.SQLAnywhere.SAConnection.GetSchema(System.String)"/>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SAMetaDataCollectionNames.UserDefinedTypes">
            <summary>
            <para>Provides a constant for use with the SAConnection.GetSchema(string) method that represents the UserDefinedTypes collection.</para>
        </summary><example>
            <para>The following code fills a DataTable with the Users collection.</para>
            <code>DataTable schema = 
    GetSchema( SAMetaDataCollectionNames.UserDefinedTypes );</code>
        </example><seealso cref="M:iAnywhere.Data.SQLAnywhere.SAConnection.GetSchema(System.String)"/>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SAMetaDataCollectionNames.ViewColumns">
            <summary>
            <para>Provides a constant for use with the SAConnection.GetSchema(string) method that represents the ViewColumns collection.</para>
        </summary><example>
            <para>The following code fills a DataTable with the ViewColumns collection.</para>
            <code>DataTable schema = GetSchema( SAMetaDataCollectionNames.ViewColumns );</code>
        </example><seealso cref="M:iAnywhere.Data.SQLAnywhere.SAConnection.GetSchema(System.String)"/>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SAMetaDataCollectionNames.Views">
            <summary>
            <para>Provides a constant for use with the SAConnection.GetSchema(string) method that represents the Views collection.</para>
        </summary><example>
            <para>The following code fills a DataTable with the Views collection.</para>
            <code>DataTable schema = GetSchema( SAMetaDataCollectionNames.Views );</code>
        </example><seealso cref="M:iAnywhere.Data.SQLAnywhere.SAConnection.GetSchema(System.String)"/>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SAConnectionOptions">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SAInternalConnection">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SAConnectionGroup">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SAConnectionPool">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SAConnectionPoolManager">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SAInfoMessageDelegate">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SAInfoMessageEventArgs">
            <summary>
            <para>Provides data for the InfoMessage event.</para>
        </summary><remarks>
            <para>There is no constructor for SAInfoMessageEventArgs.</para>
        </remarks>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAInfoMessageEventArgs.ToString">
            <summary>
            <para>Retrieves a string representation of the InfoMessage event.</para>
        </summary><returns>
	    <para>A string representing the InfoMessage event.</para>
        </returns>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAInfoMessageEventArgs.MessageType">
            <summary>
            <para>Returns the type of the message. This can be one of: Action, Info, Status, or Warning.</para>
        </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAInfoMessageEventArgs.Errors">
            <summary>
            <para>Returns the collection of messages sent from the data source.</para>
        </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAInfoMessageEventArgs.Message">
            <summary>
            <para>Returns the full text of the error sent from the data source.</para>
        </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAInfoMessageEventArgs.Source">
            <summary>
            <para>Returns the name of the SQL Anywhere .NET Data Provider.</para>
        </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAInfoMessageEventArgs.NativeError">
            <summary>
            <para>Returns the SQLCODE returned by the database.</para>
        </summary>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SAInfoMessageEventHandler">
            <summary>
            <para>Represents the method that handles the SAConnection.InfoMessage event of an SAConnection object.</para>
        </summary><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAConnection"/><seealso cref="E:iAnywhere.Data.SQLAnywhere.SAConnection.InfoMessage"/>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SAConnection">
            <summary>
   <para>Represents a connection to a SQL Anywhere database.</para>
  </summary><remarks>
   <para>For a list of connection parameters, see @olink targetdoc="dbadmin" targetptr="da-conparm"@Connection parameters@/olink@.</para>
  </remarks>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAConnection.#ctor">
            <summary>
   <para>Initializes an SAConnection object. The connection must be opened before you can perform any operations against the database.</para>
  </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAConnection.#ctor(System.String)">
            <summary>
   <para>Initializes an SAConnection object. The connection must then be opened before you can perform any operations against the database.</para>
  </summary><param name="connectionString"> A SQL Anywhere connection string. A connection string is a semicolon-separated list of keyword=value pairs. For a list of connection parameters, see @olink targetdoc="dbadmin" targetptr="da-conparm"@Connection parameters@/olink@. </param><example>
   <para>The following statement initializes an SAConnection object for a connection to a database named policies running on a SQL Anywhere database server named hr. The connection uses the user ID admin and the password money.</para>
   <code>SAConnection conn = new SAConnection( 
    "UID=admin;PWD=money;SERVER=hr;DBN=policies" ); 
conn.Open();</code>
  </example><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAConnection"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAConnection.GetPoolCount">
            <summary>
   <para>Destructs an SAConnection object.</para>
  </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAConnection.Close">
            <summary>
   <para>Closes a database connection.</para>
  </summary><remarks>
   <para>The Close method rolls back any pending transactions. It then releases the connection to the connection pool, or closes the connection if connection pooling is disabled. If Close is called while handling a StateChange event, no additional StateChange events are fired. An application can call Close multiple times.</para>
  </remarks>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAConnection.Dispose(System.Boolean)">
            <summary>
   <para>Frees the resources associated with the object.</para>
  </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAConnection.BeginDbTransaction(System.Data.IsolationLevel)">
            <summary>
   <para>Starts a database transaction.</para>
  </summary><param name="isolationLevel"> Specifies the isolation level for the transaction. </param><returns>
   <para>An object representing the new transaction.</para>
  </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAConnection.BeginTransaction">
            <summary>
   <para>Returns a transaction object. Commands associated with a transaction object are executed as a single transaction. The transaction is terminated with a call to the Commit or Rollback methods.</para>
  </summary><remarks>
   <para>To associate a command with a transaction object, use the SACommand.Transaction property.</para>
  </remarks><returns>
   <para>An SATransaction object representing the new transaction.</para>
  </returns><seealso cref="T:iAnywhere.Data.SQLAnywhere.SATransaction"/><seealso cref="P:iAnywhere.Data.SQLAnywhere.SACommand.Transaction"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAConnection.BeginTransaction(System.Data.IsolationLevel)">
            <summary>
   <para>Returns a transaction object. Commands associated with a transaction object are executed as a single transaction. The transaction is terminated with a call to the Commit or Rollback methods.</para>
  </summary><remarks>
   <para>To associate a command with a transaction object, use the SACommand.Transaction property.</para>
  </remarks><param name="isolationLevel"> A member of the SAIsolationLevel enumeration. The default value is ReadCommitted. </param><returns>
   <para>An SATransaction object representing the new transaction.</para>
  </returns><example>
   <code>SATransaction tx = 
    conn.BeginTransaction( SAIsolationLevel.ReadUncommitted );</code>
  </example><seealso cref="T:iAnywhere.Data.SQLAnywhere.SATransaction"/><seealso cref="P:iAnywhere.Data.SQLAnywhere.SACommand.Transaction"/><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAIsolationLevel"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAConnection.BeginTransaction(iAnywhere.Data.SQLAnywhere.SAIsolationLevel)">
            <summary>
   <para>Returns a transaction object. Commands associated with a transaction object are executed as a single transaction. The transaction is terminated with a call to the Commit or Rollback methods.</para>
  </summary><remarks>
   <para>To associate a command with a transaction object, use the SACommand.Transaction property.</para>
  </remarks><param name="isolationLevel"> A member of the SAIsolationLevel enumeration. The default value is ReadCommitted. </param><returns>
   <para>An SATransaction object representing the new transaction.</para>
   <para>For more information, see @olink targetdoc="programming" targetptr="transaction-adodotnet-development"@Transaction processing@/olink@.</para>
   <para>For more information, see @olink targetdoc="sqlug" targetptr="typical-isolation-transact"@Typical types of inconsistency@/olink@.</para>
  </returns><seealso cref="T:iAnywhere.Data.SQLAnywhere.SATransaction"/><seealso cref="P:iAnywhere.Data.SQLAnywhere.SACommand.Transaction"/><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAIsolationLevel"/><seealso cref="M:iAnywhere.Data.SQLAnywhere.SATransaction.Commit"/><seealso cref="M:iAnywhere.Data.SQLAnywhere.SATransaction.Rollback"/><seealso cref="M:iAnywhere.Data.SQLAnywhere.SATransaction.Rollback(System.String)"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAConnection.ChangeDatabase(System.String)">
            <summary>
   <para>Changes the current database for an open SAConnection.</para>
  </summary><param name="database"> The name of the database to use instead of the current database. </param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAConnection.CreateDbCommand">
            <summary>
   <para>Creates and returns a <see cref="T:System.Data.Common.DbCommand"></see> object associated with the current connection.</para>
  </summary><returns>
   <para>A <see cref="T:System.Data.Common.DbCommand"></see> object.</para>
  </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAConnection.CreateCommand">
            <summary>
   <para>Initializes an SACommand object.</para>
  </summary><remarks>
   <para>The command object is associated with the SAConnection object.</para>
  </remarks><returns>
   <para>An SACommand object.</para>
  </returns><seealso cref="T:iAnywhere.Data.SQLAnywhere.SACommand"/><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAConnection"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAConnection.Open">
            <summary>
   <para>Opens a database connection with the property settings specified by the SAConnection.ConnectionString.</para>
  </summary><seealso cref="P:iAnywhere.Data.SQLAnywhere.SAConnection.ConnectionString"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAConnection.EnlistTransaction(System.Transactions.Transaction)">
            <summary>
   <para>Enlists in the specified transaction as a distributed transaction.</para>
  </summary><param name="transaction"> A reference to an existing System.Transactions.Transaction in which to enlist. </param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAConnection.EnlistDistributedTransaction(System.EnterpriseServices.ITransaction)">
            <summary>
   <para>Enlists in the specified transaction as a distributed transaction.</para>
  </summary><param name="transaction"> A reference to an existing System.EnterpriseServices.ITransaction in which to enlist. </param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAConnection.ClearAllPools">
            <summary>
   <para>Empties all connection pools.</para>
  </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAConnection.ClearPool(iAnywhere.Data.SQLAnywhere.SAConnection)">
            <summary>
   <para>Empties the connection pool associated with the specified connection.</para>
  </summary><param name="connection"> The SAConnection object to be cleared from the pool. </param><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAConnection"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAConnection.GetSchema">
            <summary>
   <para>Returns the list of supported schema collections.</para>
  </summary><remarks>
   <para>See GetSchema(string,string[]) for a description of the available metadata.</para>
  </remarks>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAConnection.GetSchema(System.String)">
            <summary>
   <para>Returns information for the specified metadata collection for this SAConnection object.</para>
  </summary><remarks>
   <para>See GetSchema(string,string[]) for a description of the available metadata.</para>
  </remarks><param name="collection"> Name of the metadata collection. If a name is not provided, MetaDataCollections is used. </param><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAConnection"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAConnection.GetSchema(System.String,System.String[])">
            <summary>
   <para>Returns schema information for the data source of this SAConnection object and, if specified, uses the specified string for the schema name and the specified string array for the restriction values.</para>
  </summary><remarks>
   <para>These methods are used to query the database server for various metadata. Each type of metadata is given a collection name, which must be passed to receive that data. The default collection name is MetaDataCollections.</para>
   <para>You can query the SQL Anywhere SQL Anywhere .NET Data Provider to determine the list of supported schema collections by calling the GetSchema method with no arguments, or with the schema collection name <b>MetaDataCollections</b>. This will return a DataTable with a list of the supported schema collections (CollectionName), the number of restrictions that they each support (NumberOfRestrictions), and the number of identifier parts that they use (NumberOfIdentifierParts).</para>
   <list type="table">
    <listheader>
     <term>Collection</term>
     <term>Metadata</term>
    </listheader>
    <item>
     <term>Columns</term>
     <term>Returns information on all columns in the database.</term>
    </item>
    <item>
     <term>DataSourceInformation</term>
     <term>Returns information about the database server. </term>
    </item>
    <item>
     <term>DataTypes</term>
     <term>Returns a list of supported data types.</term>
    </item>
    <item>
     <term>ForeignKeys</term>
     <term>Returns information on all foreign keys in the database.</term>
    </item>
    <item>
     <term>IndexColumns</term>
     <term>Returns information on all index columns in the database. </term>
    </item>
    <item>
     <term>Indexes</term>
     <term>Returns information on all indexes in the database.</term>
    </item>
    <item>
     <term>MetaDataCollections</term>
     <term>Returns a list of all collection names.</term>
    </item>
    <item>
     <term>ProcedureParameters</term>
     <term>Returns information on all procedure parameters in the database.</term>
    </item>
    <item>
     <term>Procedures</term>
     <term>Returns information on all procedures in the database.</term>
    </item>
    <item>
     <term>ReservedWords</term>
     <term>Returns a list of reserved words used by SQL Anywhere.</term>
    </item>
    <item>
     <term>Restrictions</term>
     <term>Returns information on restrictions used in GetSchema.</term>
    </item>
    <item>
     <term>Tables</term>
     <term>Returns information on all tables in the database.</term>
    </item>
    <item>
     <term>UserDefinedTypes</term>
     <term>Returns information on all user-defined data types in the database.</term>
    </item>
    <item>
     <term>Users</term>
     <term>Returns information on all users in the database.</term>
    </item>
    <item>
     <term>ViewColumns</term>
     <term>Returns information on all columns in views in the database.</term>
    </item>
    <item>
     <term>Views</term>
     <term>Returns information on all views in the database.</term>
    </item>
   </list>
   <para>These collection names are also available as read-only properties in the SAMetaDataCollectionNames class.</para>
   <para>The results returned can be filtered by specifying an array of restrictions in the call to GetSchema.</para>
   <para>The restrictions available with each collection can be queried by calling:</para>
   <code>GetSchema( "Restrictions" )</code>
   <para>If the collection requires four restrictions, then the restrictions parameter must be either NULL, or a string with four values.</para>
   <para>To filter on a particular restriction, place the string to filter by in its place in the array and leave any unused places NULL. For example, the Tables collection has three restrictions: Owner, Table, and TableType.</para>
   <para>To filter the Table collection by table_name:</para>
   <code>GetSchema( "Tables", new string[ ] { NULL, "my_table", NULL } ) </code>
   <para>This returns information on all tables named my_table.</para>
   <code>GetSchema( "Tables", new string[ ] { "DBA", "my_table", NULL } )</code>
   <para>This returns information on all tables named my_table owned by the user DBA.</para>
   <para>The following is a summary of the columns returned by each collection. If the number of rows returned in a collection can be reduced by specifying a restriction on a column, the restriction name for that column is shown in parenthesis. The order in which restrictions are specified is the order in which they are presented in the lists below.</para>
   <para><b>Columns</b> collection</para>
   <list type="bullet">
    <item> table_schema (Owner) </item>
    <item> table_name (Table) </item>
    <item> column_name (Column) </item>
    <item> ordinal_position </item>
    <item> column_default </item>
    <item> is_nullable </item>
    <item> data_type </item>
    <item> precision </item>
    <item> scale </item>
    <item> column_size </item>
   </list>
   <para><b>DataSourceInformation</b> collection </para>
   <list type="bullet">
    <item> CompositeIdentifierSeparatorPattern </item>
    <item> DataSourceProductName </item>
    <item> DataSourceProductVersion </item>
    <item> DataSourceProductVersionNormalized </item>
    <item> GroupByBehavior </item>
    <item> IdentifierPattern </item>
    <item> IdentifierCase </item>
    <item> OrderByColumnsInSelect </item>
    <item> ParameterMarkerFormat </item>
    <item> ParameterMarkerPattern </item>
    <item> ParameterNameMaxLength </item>
    <item> ParameterNamePattern </item>
    <item> QuotedIdentifierPattern </item>
    <item> QuotedIdentifierCase </item>
    <item> StatementSeparatorPattern </item>
    <item> StringLiteralPattern </item>
    <item> SupportedJoinOperators </item>
   </list>
   <para><b>DataTypes</b> collection </para>
   <list type="bullet">
    <item> TypeName </item>
    <item> ProviderDbType </item>
    <item> ColumnSize </item>
    <item> CreateFormat </item>
    <item> CreateParameters </item>
    <item> DataType </item>
    <item> IsAutoIncrementable </item>
    <item> IsBestMatch </item>
    <item> IsCaseSensitive </item>
    <item> IsFixedLength </item>
    <item> IsFixedPrecisionScale </item>
    <item> IsLong </item>
    <item> IsNullable </item>
    <item> IsSearchable </item>
    <item> IsSearchableWithLike </item>
    <item> IsUnsigned </item>
    <item> MaximumScale </item>
    <item> MinimumScale </item>
    <item> IsConcurrencyType </item>
    <item> IsLiteralSupported </item>
    <item> LiteralPrefix </item>
    <item> LiteralSuffix </item>
   </list>
   <para><b>ForeignKeys</b> collection </para>
   <list type="bullet">
    <item> table_schema (Owner) </item>
    <item> table_name (Table) </item>
    <item> column_name (Column) </item>
   </list>
   <para><b>IndexColumns</b> collection </para>
   <list type="bullet">
    <item> table_schema (Owner) </item>
    <item> table_name (Table) </item>
    <item> index_name (Name) </item>
    <item> column_name (Column) </item>
    <item> order </item>
   </list>
   <para><b>Indexes</b> collection </para>
   <list type="bullet">
    <item> table_schema (Owner) </item>
    <item> table_name (Table) </item>
    <item> index_name (Name) </item>
    <item> primary_key </item>
    <item> is_unique </item>
   </list>
   <para><b>MetaDataCollections</b> collection </para>
   <list type="bullet">
    <item> CollectionName </item>
    <item> NumberOfRestrictions </item>
    <item> NumberOfIdentifierParts </item>
   </list>
   <para><b>ProcedureParameters</b> collection </para>
   <list type="bullet">
    <item> procedure_schema (Owner) </item>
    <item> procedure_name (Name) </item>
    <item> parameter_name (Parameter) </item>
    <item> data_type </item>
    <item> parameter_type </item>
    <item> is_input </item>
    <item> is_output </item>
   </list>
   <para><b>Procedures</b> collection </para>
   <list type="bullet">
    <item> procedure_schema (Owner) </item>
    <item> procedure_name (Name) </item>
   </list>
   <para><b>ReservedWords</b> collection </para>
   <list type="bullet">
    <item> reserved_word </item>
   </list>
   <para><b>Restrictions</b> collection </para>
   <list type="bullet">
    <item> CollectionName </item>
    <item> RestrictionName </item>
    <item> RestrictionDefault </item>
    <item> RestrictionNumber </item>
   </list>
   <para><b>Tables</b> collection </para>
   <list type="bullet">
    <item> table_schema (Owner) </item>
    <item> table_name (Table) </item>
    <item> table_type (TableType) either "BASE", "VIEW", "MAT VIEW", "LCL TEMP", "GBL TEMP", "TEXT", or "TEXT GBL TEMP" </item> 
   </list>
   <para><b>UserDefinedTypes</b> collection </para>
   <list type="bullet">
    <item> data_type </item>
    <item> default </item>
    <item> precision </item>
    <item> scale </item>
   </list>
   <para><b>Users</b> collection </para>
   <list type="bullet">
    <item> user_name (UserName) </item>
    <item> resource_auth </item>
    <item> database_auth </item>
    <item> schedule_auth </item>
    <item> user_group </item>
   </list>
   <para><b>ViewColumns</b> collection </para>
   <list type="bullet">
    <item> view_schema (Owner) </item>
    <item> view_name (Name) </item>
    <item> column_name (Column) </item>
   </list>
   <para><b>Views</b> collection </para>
   <list type="bullet">
    <item> view_schema (Owner) </item>
    <item> view_name (Name) </item>
   </list>
  </remarks><returns>
   <para>A DataTable that contains schema information.</para>
  </returns><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAConnection"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAConnection.ChangePassword(System.String,System.String)">
            <summary>
   <para>Changes the password for the user indicated in the connection string to the supplied new password.</para>
  </summary><param name="connectionString"> The connection string that contains enough information to connect to the database server that you want. The connection string may contain the user ID and the current password. </param><param name="newPassword"> The new password to set. This password must comply with any password security policy set on the server, including minimum length, requirements for specific characters, and so on. </param><exception cref="T:System.ArgumentNullException">
   <para>Either the connectionString or the newPassword parameter is null.</para>
  </exception><exception cref="T:System.ArgumentException">
   <para>The connection string includes the option to use integrated security.</para>
  </exception>
        </member>
        <member name="E:iAnywhere.Data.SQLAnywhere.SAConnection.InfoMessage">
            <summary>
   <para>Occurs when the SQL Anywhere database server returns a warning or informational message.</para>
  </summary><remarks>
   <para>The event handler receives an argument of type SAInfoMessageEventArgs containing data related to this event. The following SAInfoMessageEventArgs properties provide information specific to this event: NativeError, Errors, Message, MessageType, and Source.</para>
   <para>For more information, see the .NET Framework documentation for OleDbConnection.InfoMessage Event.</para>
  </remarks>
        </member>
        <member name="E:iAnywhere.Data.SQLAnywhere.SAConnection.StateChange">
            <summary>
   <para>Occurs when the state of the SAConnection object changes.</para>
  </summary><remarks>
   <para>The event handler receives an argument of type StateChangeEventArgs with data related to this event. The following StateChangeEventArgs properties provide information specific to this event: CurrentState and OriginalState.</para>
   <para>For more information, see the .NET Framework documentation for OleDbConnection.StateChange Event.</para>
  </remarks>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnection.InitString">
            <summary>
   <para>A command that is executed immediately after the connection is established.</para>
  </summary><remarks>
   <para>The InitString will be executed immediately after the connection is opened.</para>
  </remarks>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnection.ConnectionString">
            <summary>
   <para>Provides the database connection string.</para>
  </summary><remarks>
   <para>The ConnectionString is designed to match the SQL Anywhere connection string format as closely as possible with the following exception: when the Persist Security Info value is set to false (the default), the connection string that is returned is the same as the user-set ConnectionString minus security information. The SQL Anywhere SQL Anywhere .NET Data Provider does not persist the password in a returned connection string unless you set Persist Security Info to true.</para>
   <para>You can use the ConnectionString property to connect to a variety of data sources.</para>
   <para>You can set the ConnectionString property only when the connection is closed. Many of the connection string values have corresponding read-only properties. When the connection string is set, all of these properties are updated, unless an error is detected. If an error is detected, none of the properties are updated. SAConnection properties return only those settings contained in the ConnectionString.</para>
   <para>If you reset the ConnectionString on a closed connection, all connection string values and related properties are reset, including the password.</para>
   <para>When the property is set, a preliminary validation of the connection string is performed. When an application calls the Open method, the connection string is fully validated. A runtime exception is generated if the connection string contains invalid or unsupported properties.</para>
   <para>Values can be delimited by single or double quotes. Either single or double quotes may be used within a connection string by using the other delimiter, for example, name="value's" or name= 'value"s', but not name='value's' or name= ""value"". Blank characters are ignored unless they are placed within a value or within quotes. keyword=value pairs must be separated by a semicolon. If a semicolon is part of a value, it must also be delimited by quotes. Escape sequences are not supported, and the value type is irrelevant. Names are not case sensitive. If a property name occurs more than once in the connection string, the value associated with the last occurrence is used.</para>
   <para>You should use caution when constructing a connection string based on user input, such as when retrieving a user ID and password from a window, and appending it to the connection string. The application should not allow a user to embed extra connection string parameters in these values.</para>
   <para>The default value of connection pooling is true (pooling=true).</para>
  </remarks><example>
   <para>The following statements set a connection string for an ODBC data source named SQL Anywhere 12 Demo and open the connection.</para>
   <code>SAConnection conn = new SAConnection();
conn.ConnectionString = "DSN=SQL Anywhere 12 Demo";
conn.Open();</code>
  </example><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAConnection"/><seealso cref="M:iAnywhere.Data.SQLAnywhere.SAConnection.Open"/>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnection.ConnectionTimeout">
            <summary>
   <para>Gets the number of seconds before a connection attempt times out with an error.</para>
  </summary><value>15 seconds</value><example>
   <para>The following statement displays the value of the ConnectionTimeout.</para>
   <code>MessageBox.Show( conn.ConnectionTimeout.ToString( ) );</code>
  </example>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnection.Database">
            <summary>
   <para>Gets the name of the current database.</para>
  </summary><remarks>
   <para>If the connection is opened, SAConnection returns the name of the current database. Otherwise, SAConnection looks in the connection string in the following order: DatabaseName, DBN, DataSourceName, DataSource, DSN, DatabaseFile, DBF.</para>
  </remarks>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnection.DataSource">
            <summary>
   <para>Gets the name of the database server.</para>
  </summary><remarks>
   <para>If the connection is opened, the SAConnection object returns the ServerName server property. Otherwise, the SAConnection object looks in the connection string in the following order: EngineName, ServerName, Server, ENG.</para>
  </remarks><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAConnection"/>	
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnection.ServerVersion">
            <summary>
   <para>Gets a string that contains the version of the instance of SQL Anywhere to which the client is connected.</para>
  </summary><remarks>
   <para>The version is ##.##.####, where the first two digits are the major version, the next two digits are the minor version, and the last four digits are the release version. The appended string is of the form major.minor.build, where major and minor are two digits, and build is four digits.</para>
  </remarks><returns>
   <para>The version of the instance of SQL Anywhere.</para>
  </returns>	
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnection.State">
            <summary>
   <para>Indicates the state of the SAConnection object.</para>
  </summary><returns>
   <para>A System.Data.ConnectionState enumeration.</para>
  </returns>	
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnection.DbProviderFactory">
            <summary>
	    <para>Gets the singleton instance of the SAFactory class.</para>
	</summary><value>The singleton instance of the SAFactory class.</value>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.ParseReturn">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.ConnectionOptionType">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.ConnectionOptions">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilderBase">
            <summary>
   <para>Base class of the SAConnectionStringBuilder class.</para>
  </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilderBase.SetUseLongNameAsKeyword(System.Boolean)">
            <summary>
   <para>Sets a boolean value that indicates whether long connection parameter names are used in the connection string. Long connection parameter names are used by default.</para>
  </summary><param name="useLongNameAsKeyword"> A boolean value that indicates whether the long connection parameter name is used in the connection string. </param><seealso cref="M:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilderBase.GetUseLongNameAsKeyword"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilderBase.GetUseLongNameAsKeyword">
            <summary>
   <para>Gets a boolean values that indicates whether long connection parameter names are used in the connection string. </para>
  </summary><remarks>
   <para>SQL Anywhere connection parameters have both long and short forms of their names. For example, to specify the name of an ODBC data source in your connection string, you can use either of the following values: DataSourceName or DSN. By default, long connection parameter names are used to build connection strings.</para>
  </remarks><returns>
   <para>True if long connection parameter names are used to build connection strings; otherwise, false.</para>
  </returns><seealso cref="M:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilderBase.SetUseLongNameAsKeyword(System.Boolean)"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilderBase.GetKeyword(System.String)">
            <summary>
   <para>Gets the keyword for specified SAConnectionStringBuilder property.</para>
  </summary><param name="propName"> The name of the SAConnectionStringBuilder property. </param><returns>
   <para>The keyword for specified SAConnectionStringBuilder property.</para>
  </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilderBase.ContainsKey(System.String)">
            <summary>
   <para>Determines whether the SAConnectionStringBuilder object contains a specific keyword.</para>
  </summary><param name="keyword"> The keyword to locate in the SAConnectionStringBuilder. </param><returns>
   <para>True if the value associated with keyword has been set; otherwise, false.</para>
  </returns><example>
   <para>The following statement determines whether the SAConnectionStringBuilder object contains the UserID keyword.</para>
   <code>connectString.ContainsKey("UserID")</code>
  </example>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilderBase.Remove(System.String)">
            <summary>
   <para>Removes the entry with the specified key from the SAConnectionStringBuilder instance.</para>
  </summary><param name="keyword"> The key of the key/value pair to be removed from the connection string in this SAConnectionStringBuilder. </param><returns>
   <para>True if the key existed within the connection string and was removed; false if the key did not exist.</para>
  </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilderBase.ShouldSerialize(System.String)">
            <summary>
   <para>Indicates whether the specified key exists in this SAConnectionStringBuilder instance.</para>
  </summary><param name="keyword"> The key to locate in the SAConnectionStringBuilder. </param><returns>
   <para>True if the SAConnectionStringBuilder contains an entry with the specified key; otherwise false.</para>
  </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilderBase.TryGetValue(System.String,System.Object@)">
            <summary>
   <para>Retrieves a value corresponding to the supplied key from this SAConnectionStringBuilder.</para>
  </summary><param name="keyword"> The key of the item to retrieve. </param><param name="value"> The value corresponding to keyword. </param><returns>
   <para>true if keyword was found within the connection string; otherwise false.</para>
  </returns>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilderBase.Keys">
            <summary>
   <para>Gets an System.Collections.ICollection that contains the keys in the SAConnectionStringBuilder.</para>
  </summary><returns>
   <para>An System.Collections.ICollection that contains the keys in the SAConnectionStringBuilder.</para>
  </returns>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilderBase.Item(System.String)">
            <summary>
   <para>Gets or sets the value of the connection keyword.</para>
  </summary><value>An object representing the value of the specified connection keyword.</value><remarks>
   <para>If the keyword or type is invalid, an exception is raised. keyword is case insensitive.</para>
   <para>When setting the value, passing NULL clears the value.</para>
  </remarks><param name="keyword"> The name of the connection keyword. </param>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SATcpOptionsBuilder">
            <summary>
   <para>Provides a simple way to create and manage the TCP options portion of connection strings used by the SAConnection object.</para>
  </summary><remarks>
   <para>The SATcpOptionsBuilder class is not available in the .NET Compact Framework 2.0.</para>
  </remarks><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAConnection"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SATcpOptionsBuilder.#ctor">
            <summary>
   <para>Initializes an SATcpOptionsBuilder object.</para>
  </summary><remarks>
   <para>The SATcpOptionsBuilder class is not available in the .NET Compact Framework 2.0.</para>
  </remarks><example>
   <para>The following statement initializes an SATcpOptionsBuilder object.</para>
   <code>SATcpOptionsBuilder options = new SATcpOptionsBuilder( );</code>
  </example>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SATcpOptionsBuilder.#ctor(System.String)">
            <summary>
   <para>Initializes an SATcpOptionsBuilder object.</para>
  </summary><remarks>
   <para>The SATcpOptionsBuilder class is not available in the .NET Compact Framework 2.0.</para>
  </remarks><param name="options"> A SQL Anywhere TCP connection parameter options string. For a list of connection parameters, see @olink targetdoc="dbadmin" targetptr="da-conparm"@Connection parameters@/olink@.
  </param><example>
   <para>The following statement initializes an SATcpOptionsBuilder object.</para>
   <code>SATcpOptionsBuilder options = new SATcpOptionsBuilder( );</code>
  </example>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SATcpOptionsBuilder.ToString">
            <summary>
   <para>Converts the TcpOptionsBuilder object to a string representation.</para>
  </summary><returns>
   <para>The options string being built.</para>
  </returns>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SATcpOptionsBuilder.Host">
            <summary>
   <para>Gets or sets the Host option.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SATcpOptionsBuilder.Broadcast">
            <summary>
   <para>Gets or sets the Broadcast option.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SATcpOptionsBuilder.Timeout">
            <summary>
   <para>Gets or sets the Timeout option.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SATcpOptionsBuilder.DoBroadcast">
            <summary>
   <para>Gets or sets the DoBroadcast option.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SATcpOptionsBuilder.ServerPort">
            <summary>
   <para>Gets or sets the ServerPort option.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SATcpOptionsBuilder.MyIP">
            <summary>
   <para>Gets or sets the MyIP option.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SATcpOptionsBuilder.ReceiveBufferSize">
            <summary>
   <para>Gets or sets the ReceiveBufferSize option.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SATcpOptionsBuilder.SendBufferSize">
            <summary>
   <para>Gets or sets the Send BufferSize option.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SATcpOptionsBuilder.TDS">
            <summary>
   <para>Gets or sets the TDS option.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SATcpOptionsBuilder.BroadcastListener">
            <summary>
   <para>Gets or sets the BroadcastListener option.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SATcpOptionsBuilder.LocalOnly">
            <summary>
   <para>Gets or sets the LocalOnly option.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SATcpOptionsBuilder.ClientPort">
            <summary>
   <para>Gets or sets the ClientPort option.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SATcpOptionsBuilder.VerifyServerName">
            <summary>
   <para>Gets or sets the VerifyServerName option.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SATcpOptionsBuilder.LDAP">
            <summary>
   <para>Gets or sets the LDAP option.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SATcpOptionsBuilder.IPV6">
            <summary>
   <para>Gets or sets the IPV6 option.</para>
  </summary>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SACommLinksOptionsBuilder">
            <summary>
   <para>Provides a simple way to create and manage the CommLinks options portion of connection strings used by the SAConnection class.</para>
  </summary><remarks>
   <para>The SACommLinksOptionsBuilder class is not available in the .NET Compact Framework 2.0.</para>
   <para>For a list of connection parameters, see @olink targetdoc="dbadmin" targetptr="da-conparm"@Connection parameters@/olink@.</para>
  </remarks>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommLinksOptionsBuilder.#ctor">
            <summary>
   <para>Initializes an SACommLinksOptionsBuilder object.</para>
  </summary><remarks>
   <para>The SACommLinksOptionsBuilder class is not available in the .NET Compact Framework 2.0.</para>
  </remarks><example>
   <para>The following statement initializes an SACommLinksOptionsBuilder object.</para>
   <code>SACommLinksOptionsBuilder commLinks = new SACommLinksOptionsBuilder( );</code>
  </example>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommLinksOptionsBuilder.#ctor(System.String)">
            <summary>
   <para>Initializes an SACommLinksOptionsBuilder object.</para>
  </summary><remarks>
   <para>The SACommLinksOptionsBuilder class is not available in the .NET Compact Framework 2.0.</para>
  </remarks><param name="options"> A SQL Anywhere CommLinks connection parameter string. For a list of connection parameters, see @olink targetdoc="dbadmin" targetptr="da-conparm"@Connection parameters@/olink@.
  </param><example>
   <para>The following statement initializes an SACommLinksOptionsBuilder object.</para>
   <code>SACommLinksOptionsBuilder commLinks =
    new SACommLinksOptionsBuilder("TCPIP(DoBroadcast=ALL;Timeout=20)");</code>
  </example>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommLinksOptionsBuilder.SetUseLongNameAsKeyword(System.Boolean)">
            <summary>
   <para>Sets a boolean value that indicates whether long connection parameter names are used in the connection string. Long connection parameter names are used by default.</para>
  </summary><param name="useLongNameAsKeyword"> A boolean value that indicates whether the long connection parameter name is used in the connection string. </param><seealso cref="M:iAnywhere.Data.SQLAnywhere.SACommLinksOptionsBuilder.GetUseLongNameAsKeyword"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommLinksOptionsBuilder.GetUseLongNameAsKeyword">
            <summary>
   <para>Gets a boolean values that indicates whether long connection parameter names are used in the connection string. </para>
  </summary><remarks>
   <para>SQL Anywhere connection parameters have both long and short forms of their names. For example, to specify the name of an ODBC data source in your connection string, you can use either of the following values: DataSourceName or DSN. By default, long connection parameter names are used to build connection strings.</para>
  </remarks><returns>
   <para>True if long connection parameter names are used to build connection strings; otherwise, false.</para>
  </returns><seealso cref="M:iAnywhere.Data.SQLAnywhere.SACommLinksOptionsBuilder.SetUseLongNameAsKeyword(System.Boolean)"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SACommLinksOptionsBuilder.ToString">
            <summary>
   <para>Converts the SACommLinksOptionsBuilder object to a string representation.</para>
  </summary><returns>
   <para>The options string being built.</para>
  </returns>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SACommLinksOptionsBuilder.ConnectionString">
            <summary>
   <para>Gets or sets the connection string being built.</para>
  </summary><remarks>
   <para>The SACommLinksOptionsBuilder class is not available in the .NET Compact Framework 2.0.</para>
  </remarks>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SACommLinksOptionsBuilder.SharedMemory">
            <summary>
   <para>Gets or sets the SharedMemory protocol.</para>
  </summary><remarks>
   <para>The SACommLinksOptionsBuilder class is not available in the .NET Compact Framework 2.0.</para>
  </remarks>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SACommLinksOptionsBuilder.All">
            <summary>
   <para>Gets or sets the ALL CommLinks option.</para>
  </summary><remarks>
   <para>Attempt to connect using the shared memory protocol first, followed by all remaining and available communication protocols. Use this setting if you are unsure of which communication protocol(s) to use.</para>
   <para>The SACommLinksOptionsBuilder class is not available in the .NET Compact Framework 2.0.</para>
  </remarks>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SACommLinksOptionsBuilder.TcpOptionsBuilder">
            <summary>
   <para>Gets or sets a TcpOptionsBuilder object used to create a TCP options string.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SACommLinksOptionsBuilder.TcpOptionsString">
            <summary>
   <para>Gets or sets a string of TCP options.</para>
  </summary>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder">
            <summary>
   <para>Provides a simple way to create and manage the contents of connection strings used by the SAConnection class.</para>
  </summary><remarks>
   <para>The SAConnectionStringBuilder class inherits SAConnectionStringBuilderBase, which inherits DbConnectionStringBuilder. </para>
   <para>The SAConnectionStringBuilder class is not available in the .NET Compact Framework 2.0.</para>
   <para>For a list of connection parameters, see @olink targetdoc="dbadmin" targetptr="da-conparm"@Connection parameters@/olink@.</para>
  </remarks>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.#ctor">
            <summary>
   <para>Initializes a new instance of the SAConnectionStringBuilder class.</para>
  </summary><remarks>
   <para>The SAConnectionStringBuilder class is not available in the .NET Compact Framework 2.0.</para>
  </remarks>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.#ctor(System.String)">
            <summary>
   <para>Initializes a new instance of the SAConnectionStringBuilder class.</para>
  </summary><remarks>
   <para>The SAConnectionStringBuilder class is not available in the .NET Compact Framework 2.0.</para>
  </remarks><param name="connectionString"> The basis for the object's internal connection information. Parsed into keyword=value pairs. For a list of connection parameters, see @olink targetdoc="dbadmin" targetptr="da-conparm"@Connection parameters@/olink@.
  </param><example>
   <para>The following statement initializes an SAConnection object for a connection to a database named policies running on a SQL Anywhere database server named hr. The connection uses the user ID admin and the password money.</para>
   <code>SAConnectionStringBuilder conn = new SAConnectionStringBuilder(
    "UID=admin;PWD=money;SERVER=hr;DBN=policies" );</code>
  </example>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.CommLinks">
            <summary>
   <para>Gets or sets the CommLinks property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.UserID">
            <summary>
   <para>Gets or sets the UserID connection property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.Password">
            <summary>
   <para>Gets or sets the Password connection property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.NewPassword">
            <summary>
   <para>Gets or sets the NewPassword connection property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.DatabaseName">
            <summary>
   <para>Gets or sets the DatabaseName connection property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.DatabaseFile">
            <summary>
   <para>Gets or sets the DatabaseFile connection property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.DatabaseSwitches">
            <summary>
   <para>Gets or sets the DatabaseSwitches connection property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.ServerName">
            <summary>
   <para>Gets or sets the ServerName connection property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.Unconditional">
            <summary>
   <para>Gets or sets the Unconditional connection property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.StartLine">
            <summary>
   <para>Gets or sets the StartLine connection property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.ConnectionName">
            <summary>
   <para>Gets or sets the ConnectionName connection property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.AutoStop">
            <summary>
   <para>Gets or sets the AutoStop connection property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.DataSourceName">
            <summary>
   <para>Gets or sets the DataSourceName connection property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.Integrated">
            <summary>
   <para>Gets or sets the Integrated connection property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.FileDataSourceName">
            <summary>
   <para>Gets or sets the FileDataSourceName connection property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.EncryptedPassword">
            <summary>
   <para>Gets or sets the EncryptedPassword connection property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.CommBufferSize">
            <summary>
   <para>Gets or sets the CommBufferSize connection property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.Encryption">
            <summary>
   <para>Gets or sets the Encryption connection property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.LivenessTimeout">
            <summary>
   <para>Gets or sets the LivenessTimeout connection property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.LogFile">
            <summary>
   <para>Gets or sets the LogFile connection property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.DisableMultiRowFetch">
            <summary>
   <para>Gets or sets the DisableMultiRowFetch connection property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.AutoStart">
            <summary>
   <para>Gets or sets the AutoStart connection property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.Charset">
            <summary>
   <para>Gets or sets the Charset connection property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.ForceStart">
            <summary>
   <para>Gets or sets the ForceStart connection property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.AppInfo">
            <summary>
   <para>Gets or sets the AppInfo connection property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.PrefetchRows">
            <summary>
   <para>Gets or sets the PrefetchRows connection property. The default value is 200.</para>
  </summary><remarks> </remarks>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.PrefetchBuffer">
            <summary>
   <para>Gets or sets the PrefetchBuffer connection property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.DatabaseKey">
            <summary>
   <para>Gets or sets the DatabaseKey connection property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.Compress">
            <summary>
   <para>Gets or sets the Compress connection property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.CompressionThreshold">
            <summary>
   <para>Gets or sets the CompressionThreshold connection property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.IdleTimeout">
            <summary>
   <para>Gets or sets the IdleTimeout connection property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.Language">
            <summary>
   <para>Gets or sets the Language connection property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.LazyClose">
            <summary>
   <para>Gets or sets the LazyClose connection property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.RetryConnectionTimeout">
            <summary>
   <para>Gets or sets the RetryConnectionTimeout property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.Kerberos">
            <summary>
   <para>Gets or sets the Kerberos connection property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.Elevate">
            <summary>
   <para>Gets or sets the Elevate connection property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.ConnectionTimeout">
            <summary>
   <para>Gets or sets the ConnectionTimeout connection property.</para>
  </summary><example>
   <para>The following statement displays the value of the ConnectionTimeout property.</para>
   <code>MessageBox.Show( connString.ConnectionTimeout.ToString() );</code>
  </example>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.PersistSecurityInfo">
            <summary>
   <para>Gets or sets the PersistSecurityInfo connection property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.ConnectionLifetime">
            <summary>
   <para>Gets or sets the ConnectionLifetime connection property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.ConnectionReset">
            <summary>
   <para>Gets or sets the ConnectionReset connection property.</para>
  </summary><returns>
   <para>A DataTable that contains schema information.</para>
  </returns>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.Enlist">
            <summary>
   <para>Gets or sets the Enlist connection property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.MinPoolSize">
            <summary>
   <para>Gets or sets the MinPoolSize connection property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.MaxPoolSize">
            <summary>
   <para>Gets or sets the MaxPoolSize connection property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.Pooling">
            <summary>
   <para>Gets or sets the Pooling connection property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.ConnectionPool">
            <summary>
   <para>Gets or sets the ConnectionPool property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.Host">
            <summary>
   <para>Gets or sets the Host property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.NodeType">
            <summary>
   <para>Gets or sets the NodeType property.</para>
  </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAConnectionStringBuilder.InitString">
            <summary>
   <para>Gets or sets the InitString connection property.</para>
  </summary>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SAConsts">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SARowUpdatedEventArgs">
            <summary>
            <para>Provides data for the RowUpdated event.</para>
        </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SARowUpdatedEventArgs.#ctor(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)">
            <summary>
            <para>Initializes a new instance of the SARowUpdatedEventArgs class.</para>
        </summary><param name="row">
            The DataRow sent through an Update. 
        </param><param name="command">
            The IDbCommand executed when Update is called. 
        </param><param name="statementType">
            One of the StatementType values that specifies the type of query executed. 
        </param><param name="tableMapping">
            The DataTableMapping sent through an Update. 
        </param>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SARowUpdatedEventArgs.Command">
            <summary>
            <para>Gets the SACommand that is executed when <see cref="M:System.Data.Common.DataAdapter.Update(System.Data.DataSet)"/> is called.</para>
        </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SARowUpdatedEventArgs.RecordsAffected">
            <summary>
            <para>Returns the number of rows changed, inserted, or deleted by execution of the SQL statement.</para>
        </summary><value>The number of rows changed, inserted, or deleted; 0 if no rows were affected or the statement failed; and -1 for SELECT statements.</value>       
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SARowUpdatingEventArgs">
            <summary>
            <para>Provides data for the RowUpdating event.</para>
        </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SARowUpdatingEventArgs.#ctor(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)">
            <summary>
            <para>Initializes a new instance of the SARowUpdatingEventArgs class.</para>
        </summary><param name="row">
            The DataRow to update. 
        </param><param name="command">
            The IDbCommand to execute during update. 
        </param><param name="statementType">
            One of the StatementType values that specifies the type of query executed. 
        </param><param name="tableMapping">
            The DataTableMapping sent through an Update. 
        </param>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SARowUpdatingEventArgs.Command">
            <summary>
            <para>Specifies the SACommand to execute when performing the Update.</para>
        </summary>        
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SARowUpdatedEventHandler">
            <summary>
            <para>Represents the method that handles the RowUpdated event of an SADataAdapter.</para>
        </summary>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SARowUpdatingEventHandler">
            <summary>
            <para>Represents the method that handles the RowUpdating event of an SADataAdapter.</para>
        </summary>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SADataAdapter">
            <summary>
            <para>Represents a set of commands and a database connection used to fill a <see cref="T:System.Data.DataSet"/> and to update a database.</para>
        </summary><remarks>
            <para>The <see cref="T:System.Data.DataSet"/> provides a way to work with data offline. The SADataAdapter provides methods to associate a DataSet with a set of SQL statements.</para>
            <para><b>Implements:</b> <see cref="T:System.Data.IDbDataAdapter"/>, <see cref="T:System.Data.IDataAdapter"/>, <see cref="T:System.ICloneable"/></para>
            <para>For more information, see @olink targetdoc="programming" targetptr="using-adapter-access-manipulate"@Using the SADataAdapter object to access and manipulate data@/olink@ and @olink targetdoc="programming" targetptr="accessing-adodotnet-dev"@Accessing and manipulating data@/olink@.</para>
        </remarks>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataAdapter.#ctor">
            <summary>
            <para>Initializes an SADataAdapter object.</para>
        </summary><seealso cref="M:iAnywhere.Data.SQLAnywhere.SADataAdapter.#ctor(iAnywhere.Data.SQLAnywhere.SACommand)"/><seealso cref="M:iAnywhere.Data.SQLAnywhere.SADataAdapter.#ctor(System.String,iAnywhere.Data.SQLAnywhere.SAConnection)"/><seealso cref="M:iAnywhere.Data.SQLAnywhere.SADataAdapter.#ctor(System.String,System.String)"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataAdapter.#ctor(iAnywhere.Data.SQLAnywhere.SACommand)">
            <summary>
            <para>Initializes an SADataAdapter object with the specified SELECT statement.</para>
        </summary><param name="selectCommand">
            An SACommand object that is used during <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)"/> to select records from the data source for placement in the <see cref="T:System.Data.DataSet"/>. 
        </param><seealso cref="M:iAnywhere.Data.SQLAnywhere.SADataAdapter.#ctor"/><seealso cref="M:iAnywhere.Data.SQLAnywhere.SADataAdapter.#ctor(System.String,iAnywhere.Data.SQLAnywhere.SAConnection)"/><seealso cref="M:iAnywhere.Data.SQLAnywhere.SADataAdapter.#ctor(System.String,System.String)"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataAdapter.#ctor(System.String,iAnywhere.Data.SQLAnywhere.SAConnection)">
            <summary>
            <para>Initializes an SADataAdapter object with the specified SELECT statement and connection.</para>
        </summary><param name="selectCommandText">
            A SELECT statement to be used to set the SADataAdapter.SelectCommand property of the SADataAdapter object. 
        </param><param name="selectConnection">
            An SAConnection object that defines a connection to a database. 
        </param><seealso cref="M:iAnywhere.Data.SQLAnywhere.SADataAdapter.#ctor"/><seealso cref="M:iAnywhere.Data.SQLAnywhere.SADataAdapter.#ctor(iAnywhere.Data.SQLAnywhere.SACommand)"/><seealso cref="M:iAnywhere.Data.SQLAnywhere.SADataAdapter.#ctor(System.String,System.String)"/><seealso cref="P:iAnywhere.Data.SQLAnywhere.SADataAdapter.SelectCommand"/><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAConnection"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataAdapter.#ctor(System.String,System.String)">
            <summary>
            <para>Initializes an SADataAdapter object with the specified SELECT statement and connection string.</para>
        </summary><param name="selectCommandText">
            A SELECT statement to be used to set the SADataAdapter.SelectCommand property of the SADataAdapter object. 
        </param><param name="selectConnectionString">
            A connection string for a SQL Anywhere database. 
        </param><seealso cref="M:iAnywhere.Data.SQLAnywhere.SADataAdapter.#ctor"/><seealso cref="M:iAnywhere.Data.SQLAnywhere.SADataAdapter.#ctor(iAnywhere.Data.SQLAnywhere.SACommand)"/><seealso cref="M:iAnywhere.Data.SQLAnywhere.SADataAdapter.#ctor(System.String,iAnywhere.Data.SQLAnywhere.SAConnection)"/><seealso cref="P:iAnywhere.Data.SQLAnywhere.SADataAdapter.SelectCommand"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataAdapter.System#ICloneable#Clone">
            <summary>
            <para>Creates a new instance of the SADataAdapter class with the same value as an existing instance.</para>
        </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataAdapter.Dispose(System.Boolean)">
            <summary>
            <para>Releases the unmanaged resources used by the SADataAdapter object and optionally releases the managed resources.</para>
        </summary><param name="disposing">
            True releases both managed and unmanaged resources; false releases only unmanaged resources. 
        </param><seealso cref="T:iAnywhere.Data.SQLAnywhere.SADataAdapter"/>	
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataAdapter.OnRowUpdated(System.Data.Common.RowUpdatedEventArgs)">
            <summary>
            <para>Raises the RowUpdated event of a .NET Framework data provider.</para>
        </summary><param name="value">
            A <see cref="T:System.Data.Common.RowUpdatedEventArgs"/> that contains the event data. 
        </param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataAdapter.OnRowUpdating(System.Data.Common.RowUpdatingEventArgs)">
            <summary>
            <para>Raises the RowUpdating event of a .NET Framework data provider.</para>
        </summary><param name="value">
            A <see cref="T:System.Data.Common.RowUpdatingEventArgs"/> that contains the event data. 
        </param>	
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataAdapter.ClearBatch">
            <summary>
            <para>Removes all SACommand objects from the batch.</para>
        </summary><seealso cref="T:iAnywhere.Data.SQLAnywhere.SACommand"/>	
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataAdapter.InitializeBatching">
            <summary>
            <para>Initializes batching for the SADataAdapter object.</para>
        </summary><seealso cref="T:iAnywhere.Data.SQLAnywhere.SADataAdapter"/>	
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataAdapter.TerminateBatching">
            <summary>
            <para>Ends batching for the SADataAdapter object.</para>
        </summary><seealso cref="T:iAnywhere.Data.SQLAnywhere.SADataAdapter"/>	
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataAdapter.Fill(System.Data.DataSet,System.Int32,System.Int32,System.String,System.Data.IDbCommand,System.Data.CommandBehavior)">
            <summary>
            <para>Adds or refreshes rows in a <see cref="T:System.Data.DataSet"/> or <see cref="T:System.Data.DataTable"/> object with data from the database.</para>
        </summary><remarks>
            <para>Even if you use the startRecord argument to limit the number of records that are copied to the DataSet, all records in the SADataAdapter query are fetched from the database to the client. For large result sets, this can have a significant performance impact.</para>
            <para>An alternative is to use an SADataReader when a read-only, forward-only result set is sufficient, perhaps with SQL statements (ExecuteNonQuery) to undertake modifications. Another alternative is to write a stored procedure that returns only the result you need.</para>
            <para>If SelectCommand does not return any rows, no tables are added to the DataSet and no exception is raised.</para>
            <para>For more information, see @olink targetdoc="programming" targetptr="getting-data-adapter"@Getting data using the SADataAdapter object@/olink@.</para>
        </remarks><param name="dataSet">
            A <see cref="T:System.Data.DataSet"/> to fill with records and optionally, schema. 
        </param><param name="startRecord">
            The zero-based record number with which to start. 
        </param><param name="maxRecords">
            The maximum number of records to be read into the <see cref="T:System.Data.DataSet"/>. 
        </param><param name="srcTable">
            The name of the source table to use for table mapping. 
        </param><param name="command">
            The SQL SELECT statement used to retrieve rows from the data source. 
        </param><param name="behaviour">
            One of the CommandBehavior values. 
        </param><returns>
        <para>The number of rows successfully added or refreshed in the <see cref="T:System.Data.DataSet"/>.</para>
        </returns><seealso cref="T:System.Data.CommandBehavior"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataAdapter.Fill(System.Data.DataTable[],System.Int32,System.Int32,System.Data.IDbCommand,System.Data.CommandBehavior)">
            <summary>
            <para>Adds or refreshes rows in a specified range in the <see cref="T:System.Data.DataSet"/> to match those in the data source using the System.Data.DataSet and <see cref="T:System.Data.DataTable"/> names.</para>
        </summary><remarks>
            <para>Even if you use the startRecord argument to limit the number of records that are copied to the DataSet, all records in the SADataAdapter query are fetched from the database to the client. For large result sets, this can have a significant performance impact.</para>
            <para>An alternative is to use an SADataReader when a read-only, forward-only result set is sufficient, perhaps with SQL statements (ExecuteNonQuery) to undertake modifications. Another alternative is to write a stored procedure that returns only the result you need.</para>
            <para>If SelectCommand does not return any rows, no tables are added to the DataSet and no exception is raised.</para>
            <para>For more information, see @olink targetdoc="programming" targetptr="getting-data-adapter"@Getting data using the SADataAdapter object@/olink@.</para>
        </remarks><param name="dataTables">
            The <see cref="T:System.Data.DataTable"/> objects to fill from the data source. 
        </param><param name="startRecord">
            The zero-based record number to start with. 
        </param><param name="maxRecords">
            The maximum number of records to retrieve. 
        </param><param name="command">
            The System.Data.IDbCommand executed to fill the System.Data.DataTable objects. 
        </param><param name="behavior">
            One of the System.Data.CommandBehavior values. 
        </param><returns>
        <para>The number of rows added to or refreshed in the data tables.</para>
        </returns>	
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType,System.Data.IDbCommand,System.String,System.Data.CommandBehavior)">
            <summary>
            <para>Adds a <see cref="T:System.Data.DataTable"/> to a <see cref="T:System.Data.DataSet"/> and configures the schema to match the schema in the data source.</para>
        </summary><remarks>
            <para>For more information, see <see cref="M:System.Data.IDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)"/> and @olink targetdoc="programming" targetptr="sadataadapter-schema-adodotnet"@Obtaining SADataAdapter schema information@/olink@.</para>
        </remarks><param name="dataSet">
            A <see cref="T:System.Data.DataSet"/> to fill with the schema. 
        </param><param name="schemaType">
            One of the <see cref="T:System.Data.SchemaType"/> values that specify how to insert the schema. 
        </param><param name="command">
            The SQL SELECT statement used to retrieve rows from the data source. 
        </param><param name="srcTable">
            The name of the source table to use for table mapping. 
        </param><param name="behavior">
            One of the System.Data.CommandBehavior values. 
        </param><returns>
        <para>A reference to a collection of <see cref="T:System.Data.DataTable"/> objects that were added to the <see cref="T:System.Data.DataSet"/>.</para>
        </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataAdapter.FillSchema(System.Data.DataTable,System.Data.SchemaType,System.Data.IDbCommand,System.Data.CommandBehavior)">
            <summary>
            <para>Adds a <see cref="T:System.Data.DataTable"/> to a <see cref="T:System.Data.DataSet"/> and configures the schema to match the schema in the data source.</para>
        </summary><remarks>
            <para>For more information, see <see cref="M:System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataTable,System.Data.SchemaType)"/> and @olink targetdoc="programming" targetptr="sadataadapter-schema-adodotnet"@Obtaining SADataAdapter schema information@/olink@.</para>
        </remarks><param name="dataTable">
            A <see cref="T:System.Data.DataTable"/> to fill with the schema. 
        </param><param name="schemaType">
            One of the <see cref="T:System.Data.SchemaType"/> values that specify how to insert the schema. 
        </param><param name="command">
            The SQL SELECT statement used to retrieve rows from the data source. 
        </param><param name="behavior">
            One of the System.Data.CommandBehavior values. 
        </param><returns>
        <para>A reference to the <see cref="T:System.Data.DataTable"/> object that contains the schema.</para>
        </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataAdapter.GetFillParameters">
            <summary>
            <para>Returns the parameters set by you when executing a SELECT statement.</para>
        </summary><returns>
        <para>An array of IDataParameter objects that contains the parameters set by the user.</para>
        </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataAdapter.CreateRowUpdatedEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.Data.Common.RowUpdatedEventArgs"/> class.</para>
        </summary><param name="dataRow">
            The <see cref="T:System.Data.DataRow"/> used to update the data source. 
        </param><param name="command">
            The <see cref="T:System.Data.IDbCommand"/> executed during the <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)"/>. 
        </param><param name="statementType">
            Whether the command is an UPDATE, INSERT, DELETE, or SELECT statement. 
        </param><param name="tableMapping">
            A <see cref="T:System.Data.Common.DataTableMapping"/> object. 
        </param><returns>
        <para>A new instance of the <see cref="T:System.Data.Common.RowUpdatedEventArgs"/> class.</para>
        </returns>	
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataAdapter.CreateRowUpdatingEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.Data.Common.RowUpdatingEventArgs"/> class.</para>
        </summary><param name="dataRow">
            The <see cref="T:System.Data.DataRow"/> used to update the data source. 
        </param><param name="command">
            The <see cref="T:System.Data.IDbCommand"/> executed during the <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)"/>. 
        </param><param name="statementType">
            Whether the command is an UPDATE, INSERT, DELETE, or SELECT statement. 
        </param><param name="tableMapping">
            A <see cref="T:System.Data.Common.DataTableMapping"/> object. 
        </param><returns>
        <para>A new instance of the <see cref="T:System.Data.Common.RowUpdatingEventArgs"/> class.</para>
        </returns>	
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataAdapter.Update(System.Data.DataRow[],System.Data.Common.DataTableMapping)">
            <summary>
            <para>Updates the tables in a database with the changes made to the DataSet.</para>
        </summary><remarks>
            <para>The Update is carried out using the InsertCommand, UpdateCommand, and DeleteCommand on each row in the data set that has been inserted, updated, or deleted.</para>
            <para>For more information, see @olink targetdoc="programming" targetptr="inserting-data-adapter"@Inserting, updating, and deleting rows using the SADataAdapter object@/olink@.</para>
        </remarks><param name="dataRows">
            An array of <see cref="T:System.Data.DataRow"/> to update from. 
        </param><param name="tableMapping">
            The <see cref="P:System.Data.IDataAdapter.TableMappings"/> collection to use. 
        </param><returns>
        <para>The number of rows successfully updated from the <see cref="T:System.Data.DataRow"/> array.</para>
        </returns><seealso cref="P:iAnywhere.Data.SQLAnywhere.SADataAdapter.DeleteCommand"/><seealso cref="P:iAnywhere.Data.SQLAnywhere.SADataAdapter.InsertCommand"/><seealso cref="P:iAnywhere.Data.SQLAnywhere.SADataAdapter.UpdateCommand"/>	
        </member>
        <member name="E:iAnywhere.Data.SQLAnywhere.SADataAdapter.RowUpdated">
            <summary>
            <para>Occurs during an update after a command is executed against the data source. When an attempt to update is made, the event fires.</para>
        </summary><remarks>
            <para>The event handler receives an argument of type SARowUpdatedEventArgs containing data related to this event.</para>
            <para>For more information, see the .NET Framework documentation for OleDbDataAdapter.RowUpdated Event.</para>
        </remarks>
        </member>
        <member name="E:iAnywhere.Data.SQLAnywhere.SADataAdapter.RowUpdating">
            <summary>
            <para>Occurs during an update before a command is executed against the data source. When an attempt to update is made, the event fires.</para>
        </summary><remarks>
            <para>The event handler receives an argument of type SARowUpdatingEventArgs containing data related to this event.</para>
            <para>For more information, see the .NET Framework documentation for OleDbDataAdapter.RowUpdating Event.</para>
        </remarks>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SADataAdapter.UpdateBatchSize">
            <summary>
            <para>Gets or sets the number of rows that are processed in each round-trip to the server.</para>
        </summary><remarks>
            <para>The default value is 1.</para>
            <para>Setting the value to something greater than 1 causes SADataAdapter.Update to execute all the insert statements in batches. The deletions and updates are executed sequentially as before, but insertions are executed afterward in batches of size equal to the value of UpdateBatchSize. Setting the value to 0 causes Update to send the insert statements in a single batch.</para>
            <para>Setting the value to something greater than 1 causes SADataAdapter.Fill to execute all the insert statements in batches. The deletions and updates are executed sequentially as before, but insertions are executed afterward in batches of size equal to the value of UpdateBatchSize.</para>
            <para>Setting the value to 0 causes Fill to send the insert statements in a single batch.</para>
            <para>Setting it less than 0 is an error.</para>
            <para>If UpdateBatchSize is set to something other than one, and the InsertCommand property is set to something that is not an INSERT statement, then an exception is thrown when calling Fill.</para>
            <para>This behavior is different from SqlDataAdapter. It batches all types of commands.</para>
        </remarks>        
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SADataAdapter.TableMappings">
            <summary>
            <para>Specifies a collection that provides the master mapping between a source table and a DataTable.</para>
        </summary><remarks>
            <para>The default value is an empty collection.</para>
            <para>When reconciling changes, the SADataAdapter uses the DataTableMappingCollection collection to associate the column names used by the data source with the column names used by the DataSet.</para>
            <para>The TableMappings property is not available in the .NET Compact Framework 2.0.</para>
        </remarks>	
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SADataAdapter.DeleteCommand">
            <summary>
            <para>Specifies an SACommand object that is executed against the database when the Update method is called to delete rows in the database that correspond to deleted rows in the DataSet.</para>
        </summary><remarks>
            <para>If this property is not set and primary key information is present in the DataSet during Update, DeleteCommand can be generated automatically by setting SelectCommand and using the SACommandBuilder. In that case, the SACommandBuilder generates any additional commands that you do not set. This generation logic requires key column information to be present in the SelectCommand.</para>
            <para>When DeleteCommand is assigned to an existing SACommand object, the SACommand object is not cloned. The DeleteCommand maintains a reference to the existing SACommand.</para>
        </remarks><seealso cref="P:iAnywhere.Data.SQLAnywhere.SADataAdapter.SelectCommand"/>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SADataAdapter.InsertCommand">
            <summary>
            <para>Specifies an SACommand that is executed against the database when the Update method is called that adds rows to the database to correspond to rows that were inserted in the DataSet.</para>
        </summary><remarks>
            <para>The SACommandBuilder does not require key columns to generate InsertCommand.</para>
            <para>When InsertCommand is assigned to an existing SACommand object, the SACommand is not cloned. The InsertCommand maintains a reference to the existing SACommand.</para>
            <para>If this command returns rows, the rows may be added to the DataSet depending on how you set the UpdatedRowSource property of the SACommand object.</para>
        </remarks>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SADataAdapter.SelectCommand">
            <summary>
            <para>Specifies an SACommand that is used during Fill or FillSchema to obtain a result set from the database for copying into a DataSet.</para>
        </summary><remarks>
            <para>When SelectCommand is assigned to a previously-created SACommand, the SACommand is not cloned. The SelectCommand maintains a reference to the previously-created SACommand object.</para>
            <para>If the SelectCommand does not return any rows, no tables are added to the DataSet, and no exception is raised.</para>
            <para>The SELECT statement can also be specified in the SADataAdapter constructor.</para>
        </remarks>	
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SADataAdapter.UpdateCommand">
            <summary>
            <para>Specifies an SACommand that is executed against the database when the Update method is called to update rows in the database that correspond to updated rows in the DataSet.</para>
        </summary><remarks>
            <para>During Update, if this property is not set and primary key information is present in the SelectCommand, the UpdateCommand can be generated automatically if you set the SelectCommand property and use the SACommandBuilder. Then, any additional commands that you do not set are generated by the SACommandBuilder. This generation logic requires key column information to be present in the SelectCommand.</para>
            <para>When UpdateCommand is assigned to a previously-created SACommand, the SACommand is not cloned. The UpdateCommand maintains a reference to the previously-created SACommand object.</para>
            <para>If execution of this command returns rows, these rows can be merged with the DataSet depending on how you set the UpdatedRowSource property of the SACommand object.</para>
        </remarks>	
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SADataAdapter.CommandRowPair">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SADataConvert">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SADataConvert.MapDbTypeToSADbType">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SADataConvert.MapSADbTypeToDbType">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SADataConvert.MapDotNetTypeToSAType">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SADataConvert.MapSADbTypeToDotNetType">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SAUnmanagedMemory">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SADecimal">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SADate">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SATime">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SADateTime">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SADataItem">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SAColumnName">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SAColumnInfo">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SAValue">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SAParameterDM">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SAServerInfo">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SAPortInfo">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SADataReader">
            <summary>
            <para>A read-only, forward-only result set from a query or stored procedure.</para>
        </summary><remarks>
            <para>There is no constructor for SADataReader. To get an SADataReader object, execute an SACommand:</para>
            <code>SACommand cmd = new SACommand(
    "SELECT EmployeeID FROM Employees", conn );
SADataReader reader = cmd.ExecuteReader();</code>
            <para>You can only move forward through an SADataReader. If you need a more flexible object to manipulate results, use an SADataAdapter.</para>
            <para>The SADataReader retrieves rows as needed, whereas the SADataAdapter must retrieve all rows of a result set before you can carry out any action on the object. For large result sets, this difference gives the SADataReader a much faster response time.</para>
            <para><b>Implements:</b> <see cref="T:System.Data.IDataReader"/>, <see cref="T:System.IDisposable"/>, <see cref="T:System.Data.IDataRecord"/>, <see cref="T:System.ComponentModel.IListSource"/></para>
            <para>For more information, see @olink targetdoc="programming" targetptr="accessing-adodotnet-dev"@Accessing and manipulating data@/olink@.</para>
        </remarks><seealso cref="M:iAnywhere.Data.SQLAnywhere.SACommand.ExecuteReader"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataReader.Finalize">
            <summary>
            <para>Destructs an SADataReader object.</para>
        </summary>		
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataReader.Close">
            <summary>
            <para>Closes the SADataReader.</para>
        </summary><remarks>
            <para>You must explicitly call the Close method when you are finished using the SADataReader.</para>
            <para>When running in autocommit mode, a COMMIT is issued as a side effect of closing the SADataReader.</para>
        </remarks>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataReader.myDispose">
            <summary>
            <para>Frees the resources associated with the object.</para>
        </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataReader.GetEnumerator">
            <summary>
            <para>Returns a <see cref="T:System.Collections.IEnumerator"/> that iterates through the SADataReader object.</para>
        </summary><returns>
	    <para>A <see cref="T:System.Collections.IEnumerator"/> for the SADataReader object.</para>
        </returns><seealso cref="T:iAnywhere.Data.SQLAnywhere.SADataReader"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataReader.GetBoolean(System.Int32)">
            <summary>
            <para>Returns the value of the specified column as a Boolean.</para>
        </summary><remarks>
            <para>No conversions are performed, so the data retrieved must already be a Boolean.</para>
        </remarks><param name="ordinal">
            An ordinal number indicating the column from which the value is obtained. The numbering is zero-based. 
        </param><returns>
	    <para>The value of the column.</para>
        </returns><seealso cref="M:iAnywhere.Data.SQLAnywhere.SADataReader.GetOrdinal(System.String)"/><seealso cref="M:iAnywhere.Data.SQLAnywhere.SADataReader.GetFieldType(System.Int32)"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataReader.GetByte(System.Int32)">
            <summary>
            <para>Returns the value of the specified column as a Byte.</para>
        </summary><remarks>
            <para>No conversions are performed, so the data retrieved must already be a byte.</para>
        </remarks><param name="ordinal">
            An ordinal number indicating the column from which the value is obtained. The numbering is zero-based. 
        </param><returns>
	    <para>The value of the column.</para>
        </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataReader.GetBytes(System.Int32,System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            <para>Reads a stream of bytes from the specified column offset into the buffer as an array, starting at the given buffer offset.</para>
        </summary><remarks>
            <para>GetBytes returns the number of available bytes in the field. In most cases this is the exact length of the field. However, the number returned may be less than the true length of the field if GetBytes has already been used to obtain bytes from the field. This may be the case, for example, when the SADataReader is reading a large data structure into a buffer.</para>
            <para>If you pass a buffer that is a null reference (Nothing in Visual Basic), GetBytes returns the length of the field in bytes.</para>
            <para>No conversions are performed, so the data retrieved must already be a byte array.</para>
        </remarks><param name="ordinal">
            An ordinal number indicating the column from which the value is obtained. The numbering is zero-based. 
        </param><param name="dataIndex">
            The index within the column value from which to read bytes. 
        </param><param name="buffer">
            An array in which to store the data. 
        </param><param name="bufferIndex">
            The index in the array to start copying data. 
        </param><param name="length">
            The maximum length to copy into the specified buffer. 
        </param><returns>
	    <para>The number of bytes read.</para>
        </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataReader.GetChar(System.Int32)">
            <summary>
            <para>Returns the value of the specified column as a character.</para>
        </summary><remarks>
            <para>No conversions are performed, so the data retrieved must already be a character.</para>
            <para>Call the SADataReader.IsDBNull method to check for null values before calling this method.</para>
        </remarks><param name="ordinal">
            An ordinal number indicating the column from which the value is obtained. The numbering is zero-based. 
        </param><returns>
	    <para>The value of the column.</para>
        </returns><seealso cref="M:iAnywhere.Data.SQLAnywhere.SADataReader.IsDBNull(System.Int32)"/><seealso cref="M:iAnywhere.Data.SQLAnywhere.SADataReader.IsDBNull(System.Int32)"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataReader.GetChars(System.Int32,System.Int64,System.Char[],System.Int32,System.Int32)">
            <summary>
            <para>Reads a stream of characters from the specified column offset into the buffer as an array starting at the given buffer offset.</para>
        </summary><remarks>
            <para>GetChars returns the number of available characters in the field. In most cases this is the exact length of the field. However, the number returned may be less than the true length of the field if GetChars has already been used to obtain characters from the field. This may be the case, for example, when the SADataReader is reading a large data structure into a buffer.</para>
            <para>If you pass a buffer that is a null reference (Nothing in Visual Basic), GetChars returns the length of the field in characters.</para>
            <para>No conversions are performed, so the data retrieved must already be a character array.</para>
            <para>For information about handling BLOBs, see @olink targetdoc="programming" targetptr="handling-blobs-adodotnet"@Handling BLOBs@/olink@.</para>
        </remarks><param name="ordinal">
            The zero-based column ordinal. 
        </param><param name="dataIndex">
            The index within the row from which to begin the read operation. 
        </param><param name="buffer">
            The buffer into which to copy data. 
        </param><param name="bufferIndex">
            The index for buffer to begin the read operation. 
        </param><param name="length">
            The number of characters to read. 
        </param><returns>
	    <para>The actual number of characters read.</para>
        </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataReader.GetDataTypeName(System.Int32)">
            <summary>
            <para>Returns the name of the source data type.</para>
        </summary><param name="index">
            The zero-based column ordinal. 
        </param><returns>
	    <para>The name of the back-end data type.</para>
        </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataReader.GetDateTime(System.Int32)">
            <summary>
            <para>Returns the value of the specified column as a DateTime object.</para>
        </summary><remarks>
            <para>No conversions are performed, so the data retrieved must already be a DateTime object.</para>
            <para>Call the SADataReader.IsDBNull method to check for null values before calling this method.</para>
        </remarks><param name="ordinal">
            The zero-based column ordinal. 
        </param><returns>
	    <para>The value of the specified column.</para>
        </returns><seealso cref="M:iAnywhere.Data.SQLAnywhere.SADataReader.IsDBNull(System.Int32)"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataReader.GetDateTimeOffset(System.Int32)">
            <summary>
            <para>Returns the value of the specified column as a DateTimeOffset object.</para>
        </summary><remarks>
            <para>No conversions are performed, so the data retrieved must already be a DateTimeOffset object.</para>
            <para>Call the SADataReader.IsDBNull method to check for null values before calling this method.</para>
        </remarks><param name="ordinal">
            The zero-based column ordinal.
        </param><returns>
            <para>The value of the specified column.</para>
        </returns><seealso cref="M:iAnywhere.Data.SQLAnywhere.SADataReader.IsDBNull(System.Int32)"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataReader.GetTimeSpan(System.Int32)">
            <summary>
            <para>Returns the value of the specified column as a TimeSpan object.</para>
        </summary><remarks>
            <para>The column must be a SQL Anywhere TIME data type. The data is converted to TimeSpan. The Days property of TimeSpan is always set to 0.</para>
            <para>Call SADataReader.IsDBNull method to check for NULL values before calling this method.</para>
            <para>For more information, see @olink targetdoc="programming" targetptr="adodotnet-development-s-4163101"@Obtaining time values@/olink@.</para>
        </remarks><param name="ordinal">
            An ordinal number indicating the column from which the value is obtained. The numbering is zero-based. 
        </param><returns>
	    <para>The value of the specified column.</para>
        </returns><seealso cref="M:iAnywhere.Data.SQLAnywhere.SADataReader.IsDBNull(System.Int32)"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataReader.GetDecimal(System.Int32)">
            <summary>
            <para>Returns the value of the specified column as a Decimal object.</para>
        </summary><remarks>
            <para>No conversions are performed, so the data retrieved must already be a Decimal object.</para>
            <para>Call the SADataReader.IsDBNull method to check for null values before calling this method.</para>
        </remarks><param name="ordinal">
            An ordinal number indicating the column from which the value is obtained. The numbering is zero-based. 
        </param><returns>
	    <para>The value of the specified column.</para>
        </returns><seealso cref="M:iAnywhere.Data.SQLAnywhere.SADataReader.IsDBNull(System.Int32)"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataReader.GetDouble(System.Int32)">
            <summary>
            <para>Returns the value of the specified column as a double-precision floating-point number.</para>
        </summary><remarks>
            <para>No conversions are performed, so the data retrieved must already be a double-precision floating-point number.</para>
            <para>Call the SADataReader.IsDBNull method to check for null values before calling this method.</para>
        </remarks><param name="ordinal">
            An ordinal number indicating the column from which the value is obtained. The numbering is zero-based. 
        </param><returns>
	    <para>The value of the specified column.</para>
        </returns><seealso cref="M:iAnywhere.Data.SQLAnywhere.SADataReader.IsDBNull(System.Int32)"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataReader.GetFieldType(System.Int32)">
            <summary>
            Returns the Type that is the data type of the object. 
        </summary><param name="index">
            The zero-based column ordinal. 
        </param><returns>
	    <para>The type that is the data type of the object.</para>
        </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataReader.GetFloat(System.Int32)">
            <summary>
            Returns the value of the specified column as a single-precision floating-point number. 
        </summary><remarks>
            <para>No conversions are performed, so the data retrieved must already be a single-precision floating-point number.</para>
            <para>Call the SADataReader.IsDBNull method to check for null values before calling this method.</para>
        </remarks><param name="ordinal">
            An ordinal number indicating the column from which the value is obtained. The numbering is zero-based. 
        </param><returns>
	    <para>The value of the specified column.</para>
        </returns><seealso cref="M:iAnywhere.Data.SQLAnywhere.SADataReader.IsDBNull(System.Int32)"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataReader.GetGuid(System.Int32)">
            <summary>
            <para>Returns the value of the specified column as a global unique identifier (GUID).</para>
        </summary><remarks>
            <para>The data retrieved must already be a globally-unique identifier or binary(16).</para>
            <para>Call the SADataReader.IsDBNull method to check for null values before calling this method.</para>
        </remarks><param name="ordinal">
            An ordinal number indicating the column from which the value is obtained. The numbering is zero-based. 
        </param><returns>
	    <para>The value of the specified column.</para>
        </returns><seealso cref="M:iAnywhere.Data.SQLAnywhere.SADataReader.IsDBNull(System.Int32)"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataReader.GetInt16(System.Int32)">
            <summary>
            <para>Returns the value of the specified column as a 16-bit signed integer.</para>
        </summary><remarks>
            <para>No conversions are performed, so the data retrieved must already be a 16-bit signed integer.</para>
        </remarks><param name="ordinal">
            An ordinal number indicating the column from which the value is obtained. The numbering is zero-based. 
        </param><returns>
	    <para>The value of the specified column.</para>
        </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataReader.GetInt32(System.Int32)">
            <summary>
            <para>Returns the value of the specified column as a 32-bit signed integer.</para>
        </summary><remarks>
            <para>No conversions are performed, so the data retrieved must already be a 32-bit signed integer.</para>
        </remarks><param name="ordinal">
            An ordinal number indicating the column from which the value is obtained. The numbering is zero-based. 
        </param><returns>
	    <para>The value of the specified column.</para>
        </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataReader.GetInt64(System.Int32)">
            <summary>
            <para>Returns the value of the specified column as a 64-bit signed integer.</para>
        </summary><remarks>
            <para>No conversions are performed, so the data retrieved must already be a 64-bit signed integer.</para>
        </remarks><param name="ordinal">
            An ordinal number indicating the column from which the value is obtained. The numbering is zero-based. 
        </param><returns>
	    <para>The value of the specified column.</para>
        </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataReader.GetName(System.Int32)">
            <summary>
            <para>Returns the name of the specified column.</para>
        </summary><param name="index">
            The zero-based index of the column. 
        </param><returns>
	    <para>The name of the specified column.</para>
        </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataReader.GetOrdinal(System.String)">
            <summary>
            <para>Returns the column ordinal, given the column name.</para>
        </summary><remarks>
            <para>GetOrdinal performs a case-sensitive lookup first. If it fails, a second case-insensitive search is made.</para>
            <para>GetOrdinal is Japanese kana-width insensitive.</para>
            <para>Because ordinal-based lookups are more efficient than named lookups, it is inefficient to call GetOrdinal within a loop. You can save time by calling GetOrdinal once and assigning the results to an integer variable for use within the loop.</para>
        </remarks><param name="name">
            The column name. 
        </param><returns>
	    <para>The zero-based column ordinal.</para>
        </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataReader.GetSchemaTable">
            <summary>
            <para>Returns a DataTable that describes the column metadata of the SADataReader.</para>
        </summary><remarks>
            <para>This method returns metadata about each column in the following order:</para>
            <list type="table">
            <listheader>
                <term>DataTable column</term> <term>Description</term> 
            </listheader>
            <item>
            <term>ColumnName</term> <term>The name of the column or a null reference (Nothing in Visual Basic) if the column has no name. If the column is aliased in the SQL query, the alias is returned. Note that in result sets, not all columns have names and not all column names are unique. </term> 
            </item>
            <item>
            <term>ColumnOrdinal</term> <term>The ID of the column. The value is in the range [0, FieldCount -1].</term> 
            </item>
            <item>
            <term>ColumnSize</term> <term>For sized columns, the maximum length of a value in the column. For other columns, this is the size in bytes of the data type.</term> 
            </item>
            <item>
            <term>NumericPrecision</term> <term>The precision of a numeric column or DBNull if the column is not numeric.</term> 
            </item>
            <item>
            <term>NumericScale</term> <term>The scale of a numeric column or DBNull if the column is not numeric.</term> 
            </item>
            <item>
            <term>IsUnique</term> <term>True if the column is a non-computed unique column in the table (BaseTableName) it is taken from.</term> 
            </item>
            <item>
            <term>IsKey</term> <term>True if the column is one of a set of columns in the result set that taken together from a unique key for the result set. The set of columns with IsKey set to true does not need to be the minimal set that uniquely identifies a row in the result set. </term> 
            </item>
            <item>
            <term>BaseServerName</term> <term>The name of the SQL Anywhere database server used by the SADataReader. </term> 
            </item>
            <item>
            <term>BaseCatalogName</term> <term>The name of the catalog in the database that contains the column. This value is always DBNull. </term> 
            </item>
            <item>
            <term>BaseColumnName</term><term>The original name of the column in the table BaseTableName of the database or DBNull if the column is computed or if this information cannot be determined.</term> 
            </item>
            <item>
            <term>BaseSchemaName</term> <term>The name of the schema in the database that contains the column. </term> 
            </item>
            <item>
            <term>BaseTableName</term> <term>The name of the table in the database that contains the column, or DBNull if column is computed or if this information cannot be determined.</term> 
            </item>
            <item>
            <term>DataType</term> <term>The .NET data type that is most appropriate for this type of column.</term> 
            </item>
            <item>
            <term>AllowDBNull</term> <term>True if the column is nullable, false if the column is not nullable or if this information cannot be determined. </term> 
            </item>
            <item>
            <term>ProviderType</term> <term>The type of the column.</term> 
            </item>
            <item>
            <term>IsAliased</term> <term>True if the column name is an alias, false if it is not an alias.</term> 
            </item>
            <item>
            <term>IsExpression </term> <term>True if the column is an expression, false if it is a column value.</term> 
            </item>
            <item>
            <term>IsIdentity</term> <term>True if the column is an identity column, false if it is not an identity column. </term> 
            </item>
            <item>
            <term>IsAutoIncrement</term> <term>True if the column is an autoincrement or global autoincrement column, false otherwise (or if this information cannot be determined).</term> 
            </item>
            <item>
            <term>IsRowVersion</term> <term>True if the column contains a persistent row identifier that cannot be written to, and has no meaningful value except to identify the row.</term> 
            </item>
            <item>
            <term>IsHidden</term> <term>True if the column is hidden, false otherwise. </term> 
            </item>
            <item>
            <term>IsLong</term> <term>True if the column is a long varchar, long nvarchar, or a long binary column, false otherwise.</term> 
            </item>
            <item>
            <term>IsReadOnly</term> <term>True if the column is read-only, false if the column is modifiable or if its access cannot be determined.</term> 
            </item>
            </list>
            <para>For more information about these columns, see the .NET Framework documentation for SqlDataReader.GetSchemaTable.</para>
            <para>For more information, see @olink targetdoc="programming" targetptr="obtaining-schema-adodotnet-dev"@Obtaining DataReader schema information@/olink@.</para>
        </remarks><returns>
	    <para>A DataTable that describes the column metadata.</para>
        </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataReader.GetString(System.Int32)">
            <summary>
            <para>Returns the value of the specified column as a string.</para>
        </summary><remarks>
            <para>No conversions are performed, so the data retrieved must already be a string.</para>
            <para>Call the SADataReader.IsDBNull method to check for NULL values before calling this method.</para>
        </remarks><param name="ordinal">
            An ordinal number indicating the column from which the value is obtained. The numbering is zero-based. 
        </param><returns>
	    <para>The value of the specified column.</para>
        </returns><seealso cref="M:iAnywhere.Data.SQLAnywhere.SADataReader.IsDBNull(System.Int32)"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataReader.GetUInt16(System.Int32)">
            <summary>
            <para>Returns the value of the specified column as a 16-bit unsigned integer.</para>
        </summary><remarks>
            <para>No conversions are performed, so the data retrieved must already be a 16-bit unsigned integer.</para>
        </remarks><param name="ordinal">
            An ordinal number indicating the column from which the value is obtained. The numbering is zero-based. 
        </param><returns>
	    <para>The value of the specified column.</para>
        </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataReader.GetUInt32(System.Int32)">
            <summary>
            <para>Returns the value of the specified column as a 32-bit unsigned integer.</para>
        </summary><remarks>
            <para>No conversions are performed, so the data retrieved must already be a 32-bit unsigned integer.</para>
        </remarks><param name="ordinal">
            An ordinal number indicating the column from which the value is obtained. The numbering is zero-based. 
        </param><returns>
	    <para>The value of the specified column.</para>
        </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataReader.GetUInt64(System.Int32)">
            <summary>
            <para>Returns the value of the specified column as a 64-bit unsigned integer.</para>
        </summary><remarks>
            <para>No conversions are performed, so the data retrieved must already be a 64-bit unsigned integer.</para>
        </remarks><param name="ordinal">
            An ordinal number indicating the column from which the value is obtained. The numbering is zero-based. 
        </param><returns>
	    <para>The value of the specified column.</para>
        </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataReader.GetValue(System.Int32)">
            <summary>
            <para>Returns the value of the specified column as an Object.</para>
        </summary><remarks>
            <para>This method returns DBNull for NULL database columns.</para>
        </remarks><param name="ordinal">
            An ordinal number indicating the column from which the value is obtained. The numbering is zero-based. 
        </param><returns>
	    <para>The value of the specified column as an object.</para>
        </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataReader.GetValue(System.Int32,System.Int64,System.Int32)">
            <summary>
            <para>Returns a substring of the value of the specified column as an Object.</para>
        </summary><remarks>
            <para>This method returns DBNull for NULL database columns.</para>
        </remarks><param name="ordinal">
            An ordinal number indicating the column from which the value is obtained. The numbering is zero-based. 
        </param><param name="index">
            A zero-based index of the substring of the value to be obtained. 
        </param><param name="length">
            The length of the substring of the value to be obtained. 
        </param><returns>
	    <para>The substring value is returned as an object.</para>
        </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataReader.GetValues(System.Object[])">
            <summary>
            <para>Gets all the columns in the current row.</para>
        </summary><remarks>
            <para>For most applications, the GetValues method provides an efficient means for retrieving all columns, rather than retrieving each column individually.</para>
            <para>You can pass an Object array that contains fewer than the number of columns contained in the resulting row. Only the amount of data the Object array holds is copied to the array. You can also pass an Object array whose length is more than the number of columns contained in the resulting row.</para>
            <para>This method returns DBNull for NULL database columns.</para>
        </remarks><param name="values">
            An array of objects that holds an entire row of the result set. 
        </param><returns>
	    <para>The number of objects in the array.</para>
        </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataReader.IsDBNull(System.Int32)">
            <summary>
            <para>Returns a value indicating whether the column contains NULL values.</para>
        </summary><remarks>
            <para>Call this method to check for NULL column values before calling the typed get methods (for example, GetByte, GetChar, and so on) to avoid raising an exception.</para>
        </remarks><param name="ordinal">
            The zero-based column ordinal. 
        </param><returns>
	    <para>Returns true if the specified column value is equivalent to DBNull. Otherwise, it returns false.</para>
        </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataReader.NextResult">
            <summary>
            <para>Advances the SADataReader to the next result, when reading the results of batch SQL statements.</para>
        </summary><remarks>
            <para>Used to process multiple results, which can be generated by executing batch SQL statements.</para>
            <para>By default, the data reader is positioned on the first result.</para>
        </remarks><returns>
	    <para>Returns true if there are more result sets. Otherwise, it returns false.</para>
        </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataReader.Read">
            <summary>
            <para>Reads the next row of the result set and moves the SADataReader to that row.</para>
        </summary><remarks>
            <para>The default position of the SADataReader is prior to the first record. Therefore, you must call Read to begin accessing any data.</para>
        </remarks><returns>
	    <para>Returns true if there are more rows. Otherwise, it returns false.</para>
        </returns><example>
            <para>The following code fills a listbox with the values in a single column of results.</para>
            <code>while( reader.Read() ) {
    listResults.Items.Add( reader.GetValue( 0 ).ToString() );
}
listResults.EndUpdate();
reader.Close();</code>

        </example>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataReader.GetData(System.Int32)">
            <summary>
            <para>This method is not supported. When called, it throws an InvalidOperationException.</para>
        </summary><seealso cref="T:System.InvalidOperationException"/>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SADataReader.Depth">
            <summary>
            <para>Gets a value indicating the depth of nesting for the current row. The outermost table has a depth of zero.</para>
        </summary><value> The depth of nesting for the current row. </value>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SADataReader.FieldCount">
            <summary>
            <para>Gets the number of columns in the result set.</para>
        </summary><value>The number of columns in the current record.</value>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SADataReader.HasRows">
            <summary>
            <para>Gets a value that indicates whether the SADataReader contains one or more rows.</para>
        </summary><value>True if the SADataReader contains one or more rows; otherwise, false.</value>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SADataReader.IsClosed">
            <summary>
            <para>Gets a values that indicates whether the SADataReader is closed.</para>
        </summary><value>True if the SADataReader is closed; otherwise, false.</value><remarks>
            <para>IsClosed and RecordsAffected are the only properties that you can call after the SADataReader is closed.</para>
        </remarks>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SADataReader.Item(System.Int32)">
            <summary>
            <para>Returns the value of a column in its native format. In C#, this property is the indexer for the SADataReader class.</para>
        </summary><param name="index">
            The column ordinal. 
        </param>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SADataReader.Item(System.String)">
            <summary>
            <para>Returns the value of a column in its native format. In C#, this property is the indexer for the SADataReader class.</para>
        </summary><param name="name">
            The column name. 
        </param>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SADataReader.RecordsAffected">
            <summary>
            The number of rows changed, inserted, or deleted by execution of the SQL statement. 
        </summary><value>The number of rows changed, inserted, or deleted. This is 0 if no rows were affected or the statement failed, or -1 for SELECT statements.</value><remarks>
            <para>The number of rows changed, inserted, or deleted. The value is 0 if no rows were affected or the statement failed, and -1 for SELECT statements.</para>
            <para>The value of this property is cumulative. For example, if two records are inserted in batch mode, the value of RecordsAffected will be two.</para>
            <para>IsClosed and RecordsAffected are the only properties that you can call after the SADataReader is closed.</para>
        </remarks>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SADataReader.SAColumnMetaData">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SADataReader.IndexColumnInfo">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SADataSourceEnumerator">
            <summary>
            <para>Provides a mechanism for enumerating all available instances of SQL Anywhere database servers within the local network.</para>
        </summary><remarks>
            <para>There is no constructor for SADataSourceEnumerator.</para>
            <para>The SADataSourceEnumerator class is not available in the .NET Compact Framework 2.0.</para>
        </remarks>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SADataSourceEnumerator.GetDataSources">
            <summary>
            <para>Retrieves a DataTable containing information about all visible SQL Anywhere database servers.</para>
        </summary><remarks>
            <para>The returned table has four columns: ServerName, IPAddress, PortNumber, and DataBaseNames. There is a row in the table for each available database server.</para>
        </remarks><example>
            <para>The following code fills a DataTable with information for each database server that is available.</para>
            <code>DataTable servers = SADataSourceEnumerator.Instance.GetDataSources();</code>

        </example>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SADataSourceEnumerator.Instance">
            <summary>
            <para>Gets an instance of SADataSourceEnumerator, which can be used to retrieve information about all visible SQL Anywhere database servers.</para>
        </summary>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SAMessageType">
            <summary>
            <para>Identifies the type of message. This can be one of: Action, Info, Status, or Warning.</para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SAMessageType.Action">
            <summary>
            <para>Message of type ACTION.</para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SAMessageType.Info">
            <summary>
            <para>Message of type INFO.</para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SAMessageType.Status">
            <summary>
            <para>Message of type STATUS.</para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SAMessageType.Warning">
            <summary>
            <para>Message of type WARNING.</para>
        </summary>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SADbType">
            <summary>
            <para>Enumerates the SQL Anywhere .NET database data types. </para>
        </summary><remarks>
            <para>The table below lists which .NET types are compatible with each SADbType. In the case of integral types, table columns can always be set using smaller integer types, but can also be set using larger types as long as the actual value is within the range of the type.</para>
            <list type="table">
            <listheader>
                <term>SADbType</term><term>Compatible .NET type</term> <term>C# built-in type</term> <term>Visual Basic built-in type</term> 
            </listheader>
            <item>
            <term><b>BigInt</b></term> <term><see cref="T:System.Int64"/></term> <term>long</term> <term>Long</term> 
            </item>
            <item>
            <term><b>Binary</b>, <b>VarBinary</b></term> <term><see cref="T:System.Byte"/>[], or <see cref="T:System.Guid"/> if size is 16</term> <term>byte[]</term> <term>Byte()</term> 
            </item>
            <item>
            <term><b>Bit</b></term> <term><see cref="T:System.Boolean"/></term> <term>bool</term> <term>Boolean</term> 
            </item>
            <item>
            <term><b>Char</b>, <b>VarChar</b></term> <term><see cref="T:System.String"/></term> <term>String</term> <term>String</term> 
            </item>
            <item>
            <term><b>Date</b></term> <term><see cref="T:System.DateTime"/></term> <term>DateTime (no built-in type)</term> <term>Date</term> 
            </item>
            <item>
            <term><b>DateTime</b>, <b>TimeStamp</b></term> <term><see cref="T:System.DateTime"/></term> <term>DateTime (no built-in type)</term> <term>DateTime</term> 
            </item>
            <item>
            <term><b>DateTimeOffset</b>, <b>DateTimeOffset</b></term> <term><see cref="T:System.DateTimeOffset"/></term> <term>DateTimeOffset (no built-in type)</term> <term>DateTimeOffset</term> 
            </item>
            <item>
            <term><b>Decimal</b>, <b>Numeric</b></term> <term><see cref="T:System.String"/></term> <term>decimal</term> <term>Decimal</term> 
            </item>
            <item>
            <term><b>Double</b></term> <term><see cref="T:System.Double"/></term> <term>double</term> <term>Double</term> 
            </item>
            <item>
            <term><b>Float</b>, <b>Real</b></term> <term><see cref="T:System.Single"/></term> <term>float</term> <term>Single</term> 
            </item>
            <item>
            <term><b>Image</b></term> <term><see cref="T:System.Byte"/>[]</term> <term>byte[]</term> <term>Byte()</term> 
            </item>
            <item>
            <term><b>Integer</b></term> <term><see cref="T:System.Int32"/></term> <term>int</term> <term>Integer</term> 
            </item>
            <item>
            <term><b>LongBinary</b></term> <term><see cref="T:System.Byte"/>[]</term> <term>byte[]</term> <term>Byte()</term> 
            </item>
            <item>
            <term><b>LongNVarChar</b></term> <term><see cref="T:System.String"/></term> <term>String</term> <term>String</term> 
            </item>
            <item>
            <term><b>LongVarChar</b></term> <term><see cref="T:System.String"/></term> <term>String</term> <term>String</term> 
            </item>
            <item>
            <term><b>Money</b></term> <term><see cref="T:System.String"/></term> <term>decimal</term> <term>Decimal</term> 
            </item>
            <item>
            <term><b>NChar</b></term> <term><see cref="T:System.String"/></term> <term>String</term> <term>String</term> 
            </item>
            <item>
            <term><b>NText</b></term> <term><see cref="T:System.String"/></term> <term>String</term> <term>String</term> 
            </item>
            <item>
            <term><b>Numeric</b></term> <term><see cref="T:System.String"/></term> <term>decimal</term> <term>Decimal</term> 
            </item>
            <item>
            <term><b>NVarChar</b></term> <term><see cref="T:System.String"/></term> <term>String</term> <term>String</term> 
            </item>
            <item>
            <term><b>SmallDateTime</b></term> <term><see cref="T:System.DateTime"/></term><term>DateTime (no built-in type)</term> <term>Date</term> 
            </item>
            <item>
            <term><b>SmallInt</b></term> <term><see cref="T:System.Int16"/></term> <term>short</term> <term>Short</term> 
            </item>
            <item>
            <term><b>SmallMoney</b></term> <term><see cref="T:System.String"/></term> <term>decimal</term> <term>Decimal</term> 
            </item>
            <item>
            <term><b>SysName</b></term> <term><see cref="T:System.String"/></term> <term>String</term> <term>String</term> 
            </item>
            <item>
            <term><b>Text</b></term> <term><see cref="T:System.String"/></term> <term>String</term> <term>String</term> 
            </item>
            <item>
            <term><b>Time</b></term> <term><see cref="T:System.TimeSpan"/></term> <term>TimeSpan (no built-in type)</term> <term>TimeSpan (no built-in type)</term> 
            </item>
            <item>
            <term><b>TimeStamp</b></term> <term><see cref="T:System.DateTime"/></term> <term>DateTime (no built-in type)</term> <term>Date</term> 
            </item>
            <item>
            <term><b>TimeStampWithTimeZone</b></term> <term><see cref="T:System.DateTimeOffset"/></term> <term>DateTimeOffset (no built-in type)</term> <term>DateTimeOffset</term> 
            </item>
            <item>
            <term><b>TinyInt</b></term> <term><see cref="T:System.Byte"/></term> <term>byte</term> <term>Byte</term> 
            </item>
            <item>
            <term><b>UniqueIdentifier</b></term> <term><see cref="T:System.Guid"/></term> <term>Guid (no built-in type)</term> <term>Guid (no built-in type)</term> 
            </item>
            <item>
            <term><b>UniqueIdentifierStr</b></term> <term><see cref="T:System.String"/></term> <term>String</term> <term>String</term> 
            </item>
            <item>
            <term><b>UnsignedBigInt</b></term> <term><see cref="T:System.UInt64"/></term> <term>ulong</term> <term>UInt64 (no built-in type)</term> 
            </item>
            <item>
            <term><b>UnsignedInt</b></term> <term><see cref="T:System.UInt32"/></term> <term>uint</term> <term>UInt64 (no built-in type)</term> 
            </item>
            <item>
            <term><b>UnsignedSmallInt</b></term> <term><see cref="T:System.UInt16"/></term> <term>ushort</term> <term>UInt64 (no built-in type)</term> 
            </item>
            <item>
            <term><b>Xml</b></term> <term><see cref="N:System.Xml"/></term> <term>String</term> <term>String</term> 
            </item>
            </list>
            <para>Binary columns of length 16 are fully compatible with the UniqueIdentifier type.</para>
        </remarks><seealso cref="M:iAnywhere.Data.SQLAnywhere.SADataReader.GetFieldType(System.Int32)"/><seealso cref="M:iAnywhere.Data.SQLAnywhere.SADataReader.GetDataTypeName(System.Int32)"/>
            @hideinitializers
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.BigInt">
            <summary>
            <para>Signed 64-bit integer.</para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.Binary">
            <summary>
            <para>Binary data, with a specified maximum length. The enumeration values Binary and VarBinary are aliases of each other.</para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.Bit">
            <summary>
            <para>1-bit flag. </para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.Char">
            <summary>
            <para>Character data, with a specified length. This type always supports Unicode characters. The types Char and VarChar are fully compatible.</para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.Date">
            <summary>
            <para>Date information. </para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.DateTime">
            <summary>
            <para>Timestamp information (date, time). The enumeration values DateTime and TimeStamp are aliases of each other.</para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.DateTimeOffset">
            <summary>
            <para>Timestamp information (date, time) offset.</para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.Decimal">
            <summary>
            <para>Exact numerical data, with a specified precision and scale. The enumeration values Decimal and Numeric are aliases of each other.</para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.Double">
            <summary>
            <para>Double-precision floating-point number (8 bytes). </para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.Float">
            <summary>
            <para>Single-precision floating-point number (4 bytes). The enumeration values Float and Real are aliases of each other.</para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.Image">
            <summary>
            <para>Stores binary data of arbitrary length.</para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.Integer">
            <summary>
            <para>Unsigned 32-bit integer. </para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.LongBinary">
            <summary>
            <para>Binary data, with variable length. </para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.LongNVarchar">
            <summary>
            <para>Character data in the NCHAR character set, with variable length. This type always supports Unicode characters.</para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.LongVarbit">
            <summary>
	    <para>Bit arrays, with variable length. </para>
	</summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.LongVarchar">
            <summary>
            <para>Character data, with variable length. This type always supports Unicode characters.</para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.Money">
            <summary>
            <para>Monetary data.</para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.NChar">
            <summary>
            <para>Stores Unicode character data, up to 32767 characters.</para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.NText">
            <summary>
            <para>Stores Unicode character data of arbitrary length.</para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.Numeric">
            <summary>
            <para>Exact numerical data, with a specified precision and scale. The enumeration values Decimal and Numeric are aliases of each other.</para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.NVarChar">
            <summary>
            <para>Stores Unicode character data, up to 32767 characters.</para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.Real">
            <summary>
            <para>Single-precision floating-point number (4 bytes). The enumeration values Float and Real are aliases of each other.</para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.SmallDateTime">
            <summary>
            <para>A domain, implemented as TIMESTAMP.</para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.SmallInt">
            <summary>
            <para>Signed 16-bit integer. </para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.SmallMoney">
            <summary>
            <para>Stores monetary data that is less than one million currency units.</para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.SysName">
            <summary>
            <para>Stores character data of arbitrary length.</para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.Text">
            <summary>
            <para>Stores character data of arbitrary length.</para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.Time">
            <summary>
            <para>Time information. </para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.TimeStamp">
            <summary>
            <para>Timestamp information (date, time). The enumeration values DateTime and TimeStamp are aliases of each other.</para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.TimeStampWithTimeZone">
            <summary>
            <para>Timestamp information (date, time, time zone). The enumeration values DateTime and TimeStamp are aliases of each other.</para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.TinyInt">
            <summary>
            <para>Unsigned 8-bit integer.</para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.UniqueIdentifier">
            <summary>
            <para>Universally Unique Identifier (UUID/GUID). </para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.UniqueIdentifierStr">
            <summary>
            <para>A domain, implemented as CHAR( 36 ). UniqueIdentifierStr is used for remote data access when mapping Microsoft SQL Server uniqueidentifier columns.</para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.UnsignedBigInt">
            <summary>
            <para>Unsigned 64-bit integer. </para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.UnsignedInt">
            <summary>
            <para>Unsigned 32-bit integer. </para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.UnsignedSmallInt">
            <summary>
            <para>Unsigned 16-bit integer. </para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.VarBinary">
            <summary>
            <para>Binary data, with a specified maximum length. The enumeration values <b>Binary</b> and <b>VarBinary</b> are aliases of each other.</para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.VarBit">
            <summary>
	    <para>Bit arrays that are from 1 to 32767 bits in length. </para>
	</summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.VarChar">
            <summary>
            <para>Character data, with a specified maximum length. This type always supports Unicode characters. The types Char and VarChar are fully compatible.</para>
        </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADbType.Xml">
            <summary>
            <para>XML data. This type stores character data of arbitrary length, and is used to store XML documents.</para>
        </summary>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.DotNetType">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SAErrorCode">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SAError">
            <summary>
            <para>Collects information relevant to a warning or error returned by the data source.</para>
        </summary><remarks>
            <para>There is no constructor for SAError.</para>
            <para>For information about error handling, see @olink targetdoc="programming" targetptr="error-adodotnet-development"@Error handling and the SQL Anywhere .NET Data Provider@/olink@.</para>
        </remarks>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAError.ToString">
            <summary>
            <para>The complete text of the error message.</para>
        </summary><example>
            <para>The return value is a string is in the form <b>SAError:</b>, followed by the Message. For example:</para>
            <code>SAError:UserId or Password not valid.</code>

        </example>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAError.NativeError">
            <summary>
            <para>Returns database-specific error information.</para>
        </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAError.Message">
            <summary>
            <para>Returns a short description of the error.</para>
        </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAError.SqlState">
            <summary>
            <para>The SQL Anywhere five-character SQLSTATE following the ANSI SQL standard.</para>
        </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAError.Source">
            <summary>
            <para>Returns the name of the provider that generated the error.</para>
        </summary>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SAErrorCollection">
            <summary>
            <para>Collects all errors generated by the SQL Anywhere .NET Data Provider.</para>
        </summary><remarks>
            <para>There is no constructor for SAErrorCollection. Typically, an SAErrorCollection is obtained from the SAException.Errors property.</para>
            <para><b>Implements:</b> <see cref="T:System.Collections.ICollection"/>, <see cref="T:System.Collections.IEnumerable"/></para>
            <para>For information about error handling, see @olink targetdoc="programming" targetptr="error-adodotnet-development"@Error handling and the SQL Anywhere .NET Data Provider@/olink@.</para>
        </remarks><seealso cref="P:iAnywhere.Data.SQLAnywhere.SAException.Errors"/><seealso cref="P:System.Data.SqlClient.SqlClientFactory.CanCreateDataSourceEnumerator"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAErrorCollection.CopyTo(System.Array,System.Int32)">
            <summary>
            <para>Copies the elements of the SAErrorCollection into an array, starting at the given index within the array.</para>
        </summary><param name="array">
            The array into which to copy the elements. 
        </param><param name="index">
            The starting index of the array. 
        </param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAErrorCollection.GetEnumerator">
            <summary>
            <para>Returns an enumerator that iterates through the SAErrorCollection.</para>
        </summary><returns>
	    <para>An <see cref="T:System.Collections.IEnumerator"/> for the SAErrorCollection. </para>
        </returns>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAErrorCollection.Count">
            <summary>
            <para>Returns the number of errors in the collection.</para>
        </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAErrorCollection.Item(System.Int32)">
            <summary>
            <para>Returns the error at the specified index.</para>
        </summary><value>An SAError object that contains the error at the specified index.</value><param name="index">
            The zero-based index of the error to retrieve. 
        </param><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAError"/>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SAException">
            <summary>
            <para>The exception that is thrown when SQL Anywhere returns a warning or error.</para>
        </summary><remarks>
            <para>There is no constructor for SAException. Typically, an SAException object is declared in a catch. For example:</para>
            <code>...
catch( SAException ex )
{
    MessageBox.Show( ex.Errors[0].Message, "Error" );
}</code>
            <para>For information about error handling, see @olink targetdoc="programming" targetptr="error-adodotnet-development"@Error handling and the SQL Anywhere .NET Data Provider@/olink@.</para>

        </remarks>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            <para>Sets the SerializationInfo with information about the exception. Overrides <see cref="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/>.</para>
        </summary><param name="info">
            The SerializationInfo that holds the serialized object data about the exception being thrown. 
        </param><param name="context">
            The StreamingContext that contains contextual information about the source or destination. 
        </param>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAException.Errors">
            <summary>
            <para>Returns a collection of one or more <see cref="T:iAnywhere.Data.SQLAnywhere.SAError"/> objects.</para>
        </summary><remarks>
            <para>The SAErrorCollection object always contains at least one instance of the SAError object.</para>
        </remarks><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAErrorCollection"/><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAError"/>        
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAException.Message">
            <summary>
            <para>Returns the text describing the error.</para>
        </summary><remarks>
            <para>This method returns a single string that contains a concatenation of all of the Message properties of all of the SAError objects in the Errors collection. Each message, except the last one, is followed by a carriage return.</para>
        </remarks><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAError"/>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAException.Source">
            <summary>
            <para>Returns the name of the provider that generated the error.</para>
        </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAException.NativeError">
            <summary>
            <para>Returns database-specific error information.</para>
        </summary>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SAFactory">
            <summary>
            <para>Represents a set of methods for creating instances of the iAnywhere.Data.SQLAnywhere provider's implementation of the data source classes.</para>
        </summary><remarks>
            <para>There is no constructor for SAFactory.</para>
            <para>ADO.NET 2.0 adds two new classes, DbProviderFactories and DbProviderFactory, to make provider independent code easier to write. To use them with SQL Anywhere specify iAnywhere.Data.SQLAnywhere as the provider invariant name passed to GetFactory. For example:</para>
            <code>' Visual Basic
Dim factory As DbProviderFactory = _
  DbProviderFactories.GetFactory( "iAnywhere.Data.SQLAnywhere" )
Dim conn As DbConnection = _
  factory.CreateConnection()

// C#
DbProviderFactory factory = 
		DbProviderFactories.GetFactory("iAnywhere.Data.SQLAnywhere" );
DbConnection conn = factory.CreateConnection();</code>
            <para>In this example, conn is created as an SAConnection object.</para>
            <para>For an explanation of provider factories and generic programming in ADO.NET 2.0, see <a href="http://msdn2.microsoft.com/en-us/library/ms379620.aspx"></a>.</para>
            <para>The SAFactory class is not available in the .NET Compact Framework 2.0.</para>
        </remarks>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SAFactory.Instance">
            <summary>
            <para>Represents the singleton instance of the SAFactory class.</para>
        </summary><remarks>
            <para>SAFactory is a singleton class, which means only this instance of this class can exist.</para>
            <para>Normally you would not use this field directly. Instead, you get a reference to this instance of SAFactory using <see cref="M:System.Data.Common.DbProviderFactories.GetFactory(System.String)"/>. For an example, see the SAFactory description.</para>
            <para>The SAFactory class is not available in the .NET Compact Framework 2.0.</para>
        </remarks><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAFactory"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAFactory.CreateCommand">
            <summary>
            <para>Returns a strongly typed <see cref="T:System.Data.Common.DbCommand"/> instance.</para>
        </summary><returns>
	    <para>A new SACommand object typed as DbCommand.</para>
        </returns><seealso cref="T:iAnywhere.Data.SQLAnywhere.SACommand"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAFactory.CreateConnection">
            <summary>
            <para>Returns a strongly typed <see cref="T:System.Data.Common.DbConnection"/> instance.</para>
        </summary><returns>
	    <para>A new SACommand object typed as DbCommand.</para>
        </returns><seealso cref="T:iAnywhere.Data.SQLAnywhere.SACommand"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAFactory.CreateCommandBuilder">
            <summary>
            <para>Returns a strongly typed <see cref="T:System.Data.Common.DbCommandBuilder"/> instance.</para>
        </summary><returns>
	    <para>A new SACommand object typed as DbCommand.</para>
        </returns><seealso cref="T:iAnywhere.Data.SQLAnywhere.SACommand"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAFactory.CreateDataAdapter">
            <summary>
            <para>Returns a strongly typed <see cref="T:System.Data.Common.DbDataAdapter"/> instance.</para>
        </summary><returns>
	    <para>A new SACommand object typed as DbCommand.</para>
        </returns><seealso cref="T:iAnywhere.Data.SQLAnywhere.SACommand"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAFactory.CreateParameter">
            <summary>
            <para>Returns a strongly typed <see cref="T:System.Data.Common.DbParameter"/> instance.</para>
        </summary><returns>
	    <para>A new SACommand object typed as DbCommand.</para>
        </returns><seealso cref="T:iAnywhere.Data.SQLAnywhere.SACommand"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAFactory.CreatePermission(System.Security.Permissions.PermissionState)">
            <summary>
            <para>Returns a strongly-typed CodeAccessPermission instance.</para>
        </summary><param name="state">
            A member of the <see cref="T:System.Security.Permissions.PermissionState"/> enumeration.
        </param><returns>
	    <para>A new SACommand object typed as DbCommand.</para>
        </returns><seealso cref="T:iAnywhere.Data.SQLAnywhere.SACommand"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAFactory.CreateConnectionStringBuilder">
            <summary>
            <para>Returns a strongly typed <see cref="T:System.Data.Common.DbConnectionStringBuilder"/> instance.</para>
        </summary><returns>
	    <para>A new SACommand object typed as DbCommand.</para>
        </returns><seealso cref="T:iAnywhere.Data.SQLAnywhere.SACommand"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAFactory.CreateDataSourceEnumerator">
            <summary>
            <para>Returns a strongly typed <see cref="T:System.Data.Common.DbDataSourceEnumerator"/> instance.</para>
        </summary><returns>
	    <para>A new SACommand object typed as DbCommand.</para>
        </returns><seealso cref="T:iAnywhere.Data.SQLAnywhere.SACommand"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAFactory.System#IServiceProvider#GetService(System.Type)">
            <summary>
            <para>Gets the service object of the specified type.</para>
        </summary><param name="serviceType">
	    An object that specifies the type of service object to get.
	</param><returns>
	    <para>A service object of type serviceType, or null if there is no service object of type serviceType.</para>
        </returns>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAFactory.CanCreateDataSourceEnumerator">
            <summary>
            <para>Always returns true, which indicates that an SADataSourceEnumerator object can be created.</para>
        </summary><returns>
	    <para>A new SACommand object typed as DbCommand.</para>
        </returns><seealso cref="T:iAnywhere.Data.SQLAnywhere.SADataSourceEnumerator"/><seealso cref="T:iAnywhere.Data.SQLAnywhere.SACommand"/>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SADefault">
            <summary>
            <para>Represents a parameter with a default value.</para>
        </summary><remarks>
            <para>There is no constructor for SADefault.</para>
            <code>SAParameter parm = new SAParameter();
parm.Value = SADefault.Value;</code>

        </remarks>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SADefault.Value">
            <summary>
            <para>Gets the value for a default parameter. This field is read-only and static.</para>
        </summary>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SAParameter">
            <summary>
            <para>Represents a parameter to an SACommand, and optionally, its mapping to a DataSet column.</para>
        </summary><remarks>
            <para><b>Implements:</b> <see cref="T:System.Data.IDbDataParameter"/>, <see cref="T:System.Data.IDataParameter"/>, <see cref="T:System.ICloneable"/></para>
        </remarks>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAParameter.#ctor">
            <summary>
            <para>Initializes an SAParameter object with null (Nothing in Visual Basic) as its value.</para>
        </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAParameter.#ctor(System.String,System.Object)">
            <summary>
            <para>Initializes an SAParameter object with the specified parameter name and value. This constructor is not recommended; it is provided for compatibility with other data providers.</para>
        </summary><param name="parameterName">
            The name of the parameter. 
        </param><param name="value">
            An Object that is the value of the parameter. 
        </param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAParameter.#ctor(System.String,iAnywhere.Data.SQLAnywhere.SADbType)">
            <summary>
            <para>Initializes an SAParameter object with the specified parameter name and data type.</para>
        </summary><remarks>
        </remarks><param name="parameterName">
            The name of the parameter. 
        </param><param name="dbType">
            One of the SADbType values. 
        </param><seealso cref="P:iAnywhere.Data.SQLAnywhere.SAParameter.SADbType"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAParameter.#ctor(System.String,iAnywhere.Data.SQLAnywhere.SADbType,System.Int32)">
            <summary>
            <para>Initializes an SAParameter object with the specified parameter name and data type.</para>
        </summary><remarks>
        </remarks><param name="parameterName">
            The name of the parameter. 
        </param><param name="dbType">
            One of the SADbType values 
        </param><param name="size">
            The length of the parameter. 
        </param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAParameter.#ctor(System.String,iAnywhere.Data.SQLAnywhere.SADbType,System.Int32,System.String)">
            <summary>
            <para>Initializes an SAParameter object with the specified parameter name, data type, and length.</para>
        </summary><remarks>
        </remarks><param name="parameterName">
            The name of the parameter. 
        </param><param name="dbType">
            One of the SADbType values 
        </param><param name="size">
            The length of the parameter. 
        </param><param name="sourceColumn">
            The name of the source column to map. 
        </param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAParameter.#ctor(System.String,iAnywhere.Data.SQLAnywhere.SADbType,System.Int32,System.Data.ParameterDirection,System.Boolean,System.Byte,System.Byte,System.String,System.Data.DataRowVersion,System.Object)">
            <summary>
            <para>Initializes an SAParameter object with the specified parameter name, data type, length, direction, nullability, numeric precision, numeric scale, source column, source version, and value.</para>
        </summary><param name="parameterName">
            The name of the parameter. 
        </param><param name="dbType">
            One of the SADbType values 
        </param><param name="size">
            The length of the parameter. 
        </param><param name="direction">
            One of the ParameterDirection values. 
        </param><param name="isNullable">
            True if the value of the field can be null; otherwise, false. 
        </param><param name="precision">
            The total number of digits to the left and right of the decimal point to which Value is resolved. 
        </param><param name="scale">
            The total number of decimal places to which Value is resolved. 
        </param><param name="sourceColumn">
            The name of the source column to map. 
        </param><param name="sourceVersion">
            One of the DataRowVersion values. 
        </param><param name="value">
            An Object that is the value of the parameter. 
        </param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAParameter.System#ICloneable#Clone">
            <summary>
            <para>Creates a new instance of the SAParameter class with the same value as an existing instance.</para>
        </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAParameter.ResetDbType">
            <summary>
            <para>Resets the type (the values of DbType and SADbType) associated with this SAParameter.</para>
        </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAParameter.ToString">
            <summary>
            <para>Returns a string containing the ParameterName.</para>
        </summary><returns>
	    <para>The name of the parameter.</para>
        </returns>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAParameter.DbType">
            <summary>
            <para>Gets and sets the DbType of the parameter.</para>
        </summary><remarks>
            <para>The SADbType and DbType are linked. Therefore, setting the DbType changes the SADbType to a supporting SADbType.</para>
            <para>The value must be a member of the SADbType enumerator.</para>
        </remarks>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAParameter.Direction">
            <summary>
            <para>Gets and sets a value indicating whether the parameter is input-only, output-only, bidirectional, or a stored procedure return value parameter.</para>
        </summary><value>One of the ParameterDirection values.</value><remarks>
            <para>If the ParameterDirection is output, and execution of the associated SACommand does not return a value, the SAParameter contains a null value. After the last row from the last result set is read, the Output, InputOut, and ReturnValue parameters are updated.</para>
        </remarks>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAParameter.IsNullable">
            <summary>
            <para>Gets and sets a value indicating whether the parameter accepts null values.</para>
        </summary><remarks>
            <para>This property is true if null values are accepted; otherwise, it is false. The default is false. Null values are handled using the DBNull class.</para>
        </remarks>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAParameter.Offset">
            <summary>
            <para>Gets and sets the offset to the Value property.</para>
        </summary><value>The offset to the value. The default is 0.</value>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAParameter.ParameterName">
            <summary>
            <para>Gets and sets the name of the SAParameter.</para>
        </summary><value>The default is an empty string.</value><remarks>
            <para>The SQL Anywhere .NET Data Provider uses positional parameters that are marked with a question mark (?) instead of named parameters.</para>
        </remarks>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAParameter.Precision">
            <summary>
            <para>Gets and sets the maximum number of digits used to represent the Value property.</para>
        </summary><value>The value of this property is the maximum number of digits used to represent the Value property. The default value is 0, which indicates that the data provider sets the precision for the Value property.</value><remarks>
            <para>The Precision property is only used for decimal and numeric input parameters.</para>
        </remarks>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAParameter.Scale">
            <summary>
            <para>Gets and sets the number of decimal places to which Value is resolved.</para>
        </summary><value>The number of decimal places to which Value is resolved. The default is 0.</value><remarks>
            <para>The Scale property is only used for decimal and numeric input parameters.</para>
        </remarks>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAParameter.Size">
            <summary>
            <para>Gets and sets the maximum size, in bytes, of the data within the column.</para>
        </summary><value>The value of this property is the maximum size, in bytes, of the data within the column. The default value is inferred from the parameter value.</value><remarks>
            <para>The value of this property is the maximum size, in bytes, of the data within the column. The default value is inferred from the parameter value.</para>
            <para>The Size property is used for binary and string types.</para>
            <para>For variable length data types, the Size property describes the maximum amount of data to transmit to the server. For example, the Size property can be used to limit the amount of data sent to the server for a string value to the first one hundred bytes.</para>
            <para>If not explicitly set, the size is inferred from the actual size of the specified parameter value. For fixed width data types, the value of Size is ignored. It can be retrieved for informational purposes, and returns the maximum amount of bytes the provider uses when transmitting the value of the parameter to the server.</para>
        </remarks>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAParameter.SourceColumn">
            <summary>
            <para>Gets and sets the name of the source column mapped to the DataSet and used for loading or returning the value.</para>
        </summary><value>A string specifying the name of the source column mapped to the DataSet and used for loading or returning the value.</value><remarks>
            <para>When SourceColumn is set to anything other than an empty string, the value of the parameter is retrieved from the column with the SourceColumn name. If Direction is set to Input, the value is taken from the DataSet. If Direction is set to Output, the value is taken from the data source. A Direction of InputOutput is a combination of both.</para>
        </remarks>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAParameter.SourceVersion">
            <summary>
            <para>Gets and sets the DataRowVersion to use when loading Value.</para>
        </summary><remarks>
            <para>Used by UpdateCommand during an Update operation to determine whether the parameter value is set to Current or Original. This allows primary keys to be updated. This property is ignored by InsertCommand and DeleteCommand. This property is set to the version of the DataRow used by the Item property, or the GetChildRows method of the DataRow object.</para>
        </remarks>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAParameter.SADbType">
            <summary>
            <para>The SADbType of the parameter.</para>
        </summary><remarks>
            <para>The SADbType and DbType are linked. Therefore, setting the SADbType changes the DbType to a supporting DbType.</para>
            <para>The value must be a member of the SADbType enumerator.</para>
        </remarks>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAParameter.SourceColumnNullMapping">
            <summary>
            <para>Gets and sets value that indicates whether the source column is nullable. This allows SACommandBuilder to generate Update statements for nullable columns correctly.</para>
        </summary><remarks>
            <para>If the source column is nullable, true is returned; otherwise, false.</para>
        </remarks>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAParameter.Value">
            <summary>
            <para>Gets and sets the value of the parameter.</para>
        </summary><value>An Object that specifies the value of the parameter.</value><remarks>
            <para>For input parameters, the value is bound to the SACommand that is sent to the server. For output and return value parameters, the value is set on completion of the SACommand and after the SADataReader is closed.</para>
            <para>When sending a null parameter value to the server, you must specify DBNull, not null. The null value in the system is an empty object that has no value. DBNull is used to represent null values.</para>
            <para>If the application specifies the database type, the bound value is converted to that type when the SQL Anywhere .NET Data Provider sends the data to the server. The provider attempts to convert any type of value if it supports the IConvertible interface. Conversion errors may result if the specified type is not compatible with the value.</para>
            <para>Both the DbType and SADbType properties can be inferred by setting the Value.</para>
            <para>The Value property is overwritten by Update.</para>
        </remarks>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SAParameter.SAParameterConverter">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SAParameterCollection">
            <summary>
            <para>Represents all parameters to an SACommand object and, optionally, their mapping to a DataSet column.</para>
        </summary><remarks>
            <para>There is no constructor for SAParameterCollection. You obtain an SAParameterCollection object from the SACommand.Parameters property of an SACommand object.</para>
        </remarks><seealso cref="T:iAnywhere.Data.SQLAnywhere.SACommand"/><seealso cref="P:iAnywhere.Data.SQLAnywhere.SACommand.Parameters"/><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAParameter"/><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAParameterCollection"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAParameterCollection.GetParameter(System.Int32)">
            <summary>
            <para>Returns a parameter from the SAParameterCollection object.</para>
        </summary><param name="index">
            The zero-based index of the parameter within the collection. 
        </param><returns>
	    <para>A <see cref="T:System.Data.Common.DbParameter"/> from SAParameterCollection object.</para>
        </returns><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAParameterCollection"/>        
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAParameterCollection.GetParameter(System.String)">
            <summary>
            <para>Returns a parameter from the SAParameterCollection object.</para>
        </summary><param name="parameterName">
            The name of the parameter to locate. 
        </param><returns>
	    <para>A <see cref="T:System.Data.Common.DbParameter"/> from SAParameterCollection object.</para>
        </returns><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAParameterCollection"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAParameterCollection.SetParameter(System.Int32,System.Data.Common.DbParameter)">
            <summary>
            <para>Sets a parameter in the SAParameterCollection object.</para>
        </summary><param name="index">
	    The zero-based index of the parameter to set.
        </param><param name="value">
	    A <see cref="T:System.Data.Common.DbParameter"/> to be inserted into the SAParameterCollection object.
        </param><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAParameterCollection"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAParameterCollection.SetParameter(System.String,System.Data.Common.DbParameter)">
            <summary>
            <para>Sets a parameter in the SAParameterCollection object.</para>
        </summary><param name="parameterName">
            The name of the parameter to set. 
        </param><param name="value">
	    A <see cref="T:System.Data.Common.DbParameter"/> to be inserted into the SAParameterCollection object.
        </param><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAParameterCollection"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAParameterCollection.Add(System.Object)">
            <summary>
            <para>Adds an SAParameter object to this collection.</para>
        </summary><param name="value">
            The SAParameter object to add to the collection. 
        </param><returns>
	    <para>The index of the new SAParameter object.</para>
        </returns><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAParameter"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAParameterCollection.Add(iAnywhere.Data.SQLAnywhere.SAParameter)">
            <summary>
            <para>Adds an SAParameter object to this collection.</para>
        </summary><param name="value">
            The SAParameter object to add to the collection. 
        </param><returns>
	    <para>The new SAParameter object.</para>
        </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAParameterCollection.Add(System.String,System.Object)">
            <summary>
            <para>Adds an SAParameter object to this collection, created using the specified parameter name and value, to the collection.</para>
        </summary><remarks>
            <para>Because of the special treatment of the 0 and 0.0 constants and the way overloaded methods are resolved, it is highly recommended that you explicitly cast constant values to type object when using this method.</para>
        </remarks><param name="parameterName">
            The name of the parameter. 
        </param><param name="value">
            The value of the parameter to add to the connection. 
        </param><returns>
	    <para>The new SAParameter object.</para>
        </returns><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAParameter"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAParameterCollection.Add(System.String,iAnywhere.Data.SQLAnywhere.SADbType)">
            <summary>
            <para>Adds an SAParameter object to this collection, created using the specified parameter name and data type, to the collection.</para>
        </summary><param name="parameterName">
            The name of the parameter. 
        </param><param name="saDbType">
            One of the SADbType values. 
        </param><returns>
	    <para>The new SAParameter object.</para>
        </returns><seealso cref="T:iAnywhere.Data.SQLAnywhere.SADbType"/><seealso cref="M:iAnywhere.Data.SQLAnywhere.SAParameterCollection.Add(iAnywhere.Data.SQLAnywhere.SAParameter)"/><seealso cref="M:iAnywhere.Data.SQLAnywhere.SAParameterCollection.Add(System.String,System.Object)"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAParameterCollection.Add(System.String,iAnywhere.Data.SQLAnywhere.SADbType,System.Int32)">
            <summary>
            <para>Adds an SAParameter object to this collection, created using the specified parameter name, data type, and length, to the collection.</para>
        </summary><param name="parameterName">
            The name of the parameter. 
        </param><param name="saDbType">
            One of the SADbType values. 
        </param><param name="size">
            The length of the parameter. 
        </param><returns>
	    <para>The new SAParameter object.</para>
        </returns><seealso cref="T:iAnywhere.Data.SQLAnywhere.SADbType"/><seealso cref="M:iAnywhere.Data.SQLAnywhere.SAParameterCollection.Add(iAnywhere.Data.SQLAnywhere.SAParameter)"/><seealso cref="M:iAnywhere.Data.SQLAnywhere.SAParameterCollection.Add(System.String,System.Object)"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAParameterCollection.Add(System.String,iAnywhere.Data.SQLAnywhere.SADbType,System.Int32,System.String)">
            <summary>
            <para>Adds an SAParameter object to this collection, created using the specified parameter name, data type, length, and source column name, to the collection.</para>
        </summary><param name="parameterName">
            The name of the parameter. 
        </param><param name="saDbType">
            One of the SADbType values. 
        </param><param name="size">
            The length of the column. 
        </param><param name="sourceColumn">
            The name of the source column to map. 
        </param><returns>
	    <para>The new SAParameter object.</para>
        </returns><seealso cref="T:iAnywhere.Data.SQLAnywhere.SADbType"/><seealso cref="M:iAnywhere.Data.SQLAnywhere.SAParameterCollection.Add(iAnywhere.Data.SQLAnywhere.SAParameter)"/><seealso cref="M:iAnywhere.Data.SQLAnywhere.SAParameterCollection.Add(System.String,System.Object)"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAParameterCollection.AddWithValue(System.String,System.Object)">
            <summary>
	    <para>Adds a value to the end of this collection.</para>
	</summary><param name="parameterName">
	    The name of the parameter.
	</param><param name="value">
	    The value to be added.
	</param><returns>
	    <para>The new SAParameter object.</para>
	</returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAParameterCollection.AddRange(System.Array)">
            <summary>
            <para>Adds an array of values to the end of the SAParameterCollection.</para>
        </summary><param name="values">
            The values to add. 
        </param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAParameterCollection.AddRange(iAnywhere.Data.SQLAnywhere.SAParameter[])">
            <summary>
            <para>Adds an array of values to the end of the SAParameterCollection.</para>
        </summary><param name="values">
            An array of SAParameter objects to add to the end of this collection. 
        </param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAParameterCollection.Clear">
            <summary>
            <para>Removes all items from the collection.</para>
        </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAParameterCollection.Contains(System.Object)">
            <summary>
            <para>Indicates whether an SAParameter object exists in the collection.</para>
        </summary><param name="value">
            The SAParameter object to find. 
        </param><returns>
	    <para>True if the collection contains the SAParameter object. Otherwise, false.</para>
        </returns><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAParameter"/><seealso cref="M:iAnywhere.Data.SQLAnywhere.SAParameterCollection.Contains(System.String)"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAParameterCollection.Contains(System.String)">
            <summary>
            <para>Indicates whether an SAParameter object exists in the collection.</para>
        </summary><param name="value">
            The name of the parameter to search for. 
        </param><returns>
	    <para>True if the collection contains the SAParameter object. Otherwise, false.</para>
        </returns><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAParameter"/><seealso cref="M:iAnywhere.Data.SQLAnywhere.SAParameterCollection.Contains(System.Object)"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAParameterCollection.CopyTo(System.Array,System.Int32)">
            <summary>
            <para>Copies SAParameter objects from the SAParameterCollection to the specified array.</para>
        </summary><param name="array">
            The array to copy the SAParameter objects into. 
        </param><param name="index">
            The starting index of the array. 
        </param><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAParameter"/><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAParameterCollection"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAParameterCollection.IndexOf(System.Object)">
            <summary>
            <para>Returns the location of the SAParameter object in the collection.</para>
        </summary><param name="value">
            The SAParameter object to locate. 
        </param><returns>
	    <para>The zero-based location of the SAParameter object in the collection.</para>
        </returns><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAParameter"/><seealso cref="M:iAnywhere.Data.SQLAnywhere.SAParameterCollection.IndexOf(System.String)"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAParameterCollection.IndexOf(System.String)">
            <summary>
            <para>Returns the location of the SAParameter object in the collection.</para>
        </summary><param name="parameterName">
            The name of the parameter to locate. 
        </param><returns>
	    <para>The zero-based index of the SAParameter object in the collection.</para>
        </returns><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAParameter"/><seealso cref="M:iAnywhere.Data.SQLAnywhere.SAParameterCollection.IndexOf(System.Object)"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAParameterCollection.Insert(System.Int32,System.Object)">
            <summary>
            <para>Inserts an SAParameter object in the collection at the specified index.</para>
        </summary><param name="index">
            The zero-based index where the parameter is to be inserted within the collection. 
        </param><param name="value">
            The SAParameter object to add to the collection. 
        </param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAParameterCollection.Remove(System.Object)">
            <summary>
            <para>Removes the specified SAParameter object from the collection.</para>
        </summary><param name="value">
            The SAParameter object to remove from the collection. 
        </param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAParameterCollection.RemoveAt(System.Int32)">
            <summary>
            <para>Removes the specified SAParameter object from the collection.</para>
        </summary><param name="index">
            The zero-based index of the parameter to remove. 
        </param><seealso cref="M:iAnywhere.Data.SQLAnywhere.SAParameterCollection.RemoveAt(System.String)"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAParameterCollection.RemoveAt(System.String)">
            <summary>
            <para>Removes the specified SAParameter object from the collection.</para>
        </summary><param name="parameterName">
            The name of the SAParameter object to remove. 
        </param><seealso cref="M:iAnywhere.Data.SQLAnywhere.SAParameterCollection.RemoveAt(System.Int32)"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAParameterCollection.GetEnumerator">
            <summary>
            <para>Returns an enumerator that iterates through the SAParameterCollection.</para>
        </summary><returns>
	    <para>An <see cref="T:System.Collections.IEnumerator"/> for the SAParameterCollection object.</para>
        </returns><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAParameterCollection"/>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAParameterCollection.Count">
            <summary>
            <para>Returns the number of SAParameter objects in the collection.</para>
        </summary><value>The number of SAParameter objects in the collection.</value><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAParameter"/><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAParameterCollection"/>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAParameterCollection.Item(System.Int32)">
            <summary>
            <para>Gets and sets the SAParameter object at the specified index.</para>
        </summary><value>An SAParameter object.</value><remarks>
            <para>In C#, this property is the indexer for the SAParameterCollection object.</para>
        </remarks><param name="index">
            The zero-based index of the parameter to retrieve. 
        </param><returns>
	    <para>The SAParameter at the specified index.</para>
        </returns><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAParameter"/><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAParameterCollection"/>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAParameterCollection.Item(System.String)">
            <summary>
            <para>Gets and sets the SAParameter object at the specified index.</para>
        </summary><value>An SAParameter object.</value><remarks>
            <para>In C#, this property is the indexer for the SAParameterCollection object.</para>
        </remarks><param name="parameterName">
            The name of the parameter to retrieve. 
        </param><returns>
	    <para>The SAParameter object with the specified name.</para>
        </returns><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAParameter"/><seealso cref="T:iAnywhere.Data.SQLAnywhere.SAParameterCollection"/><seealso cref="P:iAnywhere.Data.SQLAnywhere.SADataReader.Item(System.Int32)"/><seealso cref="M:iAnywhere.Data.SQLAnywhere.SADataReader.GetOrdinal(System.String)"/><seealso cref="M:iAnywhere.Data.SQLAnywhere.SADataReader.GetValue(System.Int32)"/><seealso cref="M:iAnywhere.Data.SQLAnywhere.SADataReader.GetFieldType(System.Int32)"/>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAParameterCollection.IsSynchronized">
            <summary>
            <para>Gets a value that indicates whether the SAParameterCollection object is synchronized.</para>
        </summary><value>True if this collection is synchronized, false otherwise.</value>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAParameterCollection.SyncRoot">
            <summary>
            <para>Gets an object that can be used to synchronize access to the SAParameterCollection.</para>
        </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAParameterCollection.IsReadOnly">
            <summary>
            <para>Gets a value that indicates whether the SAParameterCollection is read-only.</para>
        </summary><value>True if this collection is read-only, false otherwise.</value>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SAParameterCollection.IsFixedSize">
            <summary>
            <para>Gets a value that indicates whether the SAParameterCollection has a fixed size.</para>
        </summary><value>True if this collection has a fixed size, false otherwise.</value>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SAPermission">
            <summary>
            <para>Enables the SQL Anywhere .NET Data Provider to ensure that a user has a security level adequate to access a SQL Anywhere data source.</para>
        </summary><remarks>
            <para><b>Base classes </b> <see cref="T:System.Data.Common.DBDataPermission"/></para>
        </remarks>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAPermission.#ctor(System.Security.Permissions.PermissionState)">
            <summary>
            <para>Initializes a new instance of the SAPermission class.</para>
        </summary><param name="state">
            One of the PermissionState values. 
        </param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAPermission.CreateInstance">
            <summary>
            <para>Creates a new instance of an SAPermission class.</para>
        </summary><returns>
	    <para>A new SAPermission object.</para>
        </returns>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SAPermissionAttribute">
            <summary>
            <para>Associates a security action with a custom security attribute.</para>
        </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAPermissionAttribute.#ctor(System.Security.Permissions.SecurityAction)">
            <summary>
            <para>Initializes a new instance of the SAPermissionAttribute class.</para>
        </summary><param name="action">
            One of the SecurityAction values representing an action that can be performed using declarative security. 
        </param><returns>
	    <para>An SAPermissionAttribute object.</para>
        </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAPermissionAttribute.CreatePermission">
            <summary>
            <para>Returns an SAPermission object that is configured according to the attribute properties.</para>
        </summary>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.PInvokeMethods">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SARes">
            @internal
        </member>
        <member name="T:iAnywhere.SQLAnywhere.Server.SAServerSideConnection">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SATrace">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SAIsolationLevel">
            <summary>
            <para>Specifies SQL Anywhere isolation levels. This class augments the <see cref="T:System.Data.IsolationLevel"/> class.</para>
        </summary><remarks>
            <para>The SQL Anywhere .NET Data Provider supports all SQL Anywhere isolation levels, including the snapshot isolation levels. To use snapshot isolation, specify one of SAIsolationLevel.Snapshot, SAIsolationLevel.ReadOnlySnapshot, or SAIsolationLevel.StatementSnapshot as the parameter to BeginTransaction. BeginTransaction has been overloaded so it can take either an IsolationLevel or an SAIsolationLevel. The values in the two enumerations are the same, except for ReadOnlySnapshot and StatementSnapshot which exist only in SAIsolationLevel. There is a new property in SATransaction called SAIsolationLevel that gets the SAIsolationLevel.</para>
            <para>For more information, see @olink targetdoc="sqlug" targetptr="transact-s-4136352"@Snapshot isolation@/olink@.</para>
        </remarks>
            @hideinitializers
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SAIsolationLevel.Chaos">
            <summary>
            <para>This isolation level is unsupported.</para>
        </summary><remarks>
            <para>If you call SAConnection.BeginTransaction with this isolation level, an exception is thrown.</para>
            <para>For more information, see @olink targetdoc="programming" targetptr="programming-api-saconnection-cla-begintransaction-met"@BeginTransaction method@/olink@.</para>
        </remarks>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SAIsolationLevel.ReadCommitted">
            <summary>
            <para>Sets the behavior to be equivalent to isolation level 1.</para>
        </summary><remarks>
            <para>This isolation level prevents dirty reads, but allows non-repeatable reads and phantom rows.</para>
            <para>For more information, see @olink targetdoc="sqlug" targetptr="udtisol"@Isolation levels and consistency@/olink@.</para>
        </remarks>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SAIsolationLevel.ReadUncommitted">
            <summary>
            <para>Sets the behavior to be equivalent to isolation level 0.</para>
        </summary><remarks>
            <para>This isolation level allows dirty reads, non-repeatable reads, and phantom rows.</para>
            <para>For more information, see @olink targetdoc="sqlug" targetptr="udtisol"@Isolation levels and consistency@/olink@.</para>
        </remarks>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SAIsolationLevel.RepeatableRead">
            <summary>
            <para>Sets the behavior to be equivalent to isolation level 2.</para>
        </summary><remarks>
            <para>This isolation level prevents dirty reads and guarantees repeatable reads. However, it allows phantom rows.</para>
            <para>For more information, see @olink targetdoc="sqlug" targetptr="udtisol"@Isolation levels and consistency@/olink@.</para>
        </remarks>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SAIsolationLevel.Serializable">
            <summary>
            <para>Sets the behavior to be equivalent to isolation level 3.</para>
        </summary><remarks>
            <para>This isolation level prevents dirty reads, guarantees repeatable reads, and prevents phantom rows.</para>
            <para>For more information, see @olink targetdoc="sqlug" targetptr="udtisol"@Isolation levels and consistency@/olink@.</para>
        </remarks>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SAIsolationLevel.Snapshot">
            <summary>
            <para>Uses a snapshot of committed data from the time when the first row is read, inserted, updated, or deleted by the transaction.</para>
        </summary><remarks>
            <para>This isolation level uses a snapshot of committed data from the time when the first row is read or updated by the transaction.</para>
            <para>For more information, see @olink targetdoc="sqlug" targetptr="udtisol"@Isolation levels and consistency@/olink@.</para>
        </remarks>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SAIsolationLevel.Unspecified">
            <summary>
            <para>This isolation level is unsupported.</para>
        </summary><remarks>
            <para>If you call SAConnection.BeginTransaction with this isolation level, an exception is thrown.</para>
            <para>For more information, see @olink targetdoc="programming" targetptr="programming-api-saconnection-cla-begintransaction-met"@BeginTransaction method@/olink@.</para>
        </remarks>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SAIsolationLevel.ReadOnlySnapshot">
            <summary>
            <para>For read-only statements, use a snapshot of committed data from the time when the first row is read from the database.</para>
        </summary><remarks>
            <para>Non-repeatable reads and phantom rows can occur within a transaction, but not within a single statement. For updatable statements, use the isolation level specified by the updatable_statement_isolation option (can be one of 0 (the default), 1, 2, or 3).</para>
            <para>For more information, see @olink targetdoc="sqlug" targetptr="udtisol"@Isolation levels and consistency@/olink@.</para>
        </remarks>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SAIsolationLevel.StatementSnapshot">
            <summary>
            <para>Use a snapshot of committed data from the time when the first row is read by the statement. Each statement within the transaction sees a snapshot of data from a different time.</para>
        </summary><remarks>
            <para>For each statement, use a snapshot of committed data from the time when the first row is read from the database. Non-repeatable reads and phantom rows can occur within a transaction, but not within a single statement.</para>
            <para>For more information, see @olink targetdoc="sqlug" targetptr="udtisol"@Isolation levels and consistency@/olink@.</para>
        </remarks>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.DurableResourceManager">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SATransaction">
            <summary>
            <para>Represents a SQL transaction.</para>
        </summary><remarks>
            <para>There is no constructor for SATransaction. To obtain an SATransaction object, use one of the BeginTransaction methods. To associate a command with a transaction, use the SACommand.Transaction property.</para>
            <para>For more information, see @olink targetdoc="programming" targetptr="transaction-adodotnet-development"@Transaction processing@/olink@ and @olink targetdoc="programming" targetptr="inserting-data-command"@Inserting, updating, and deleting rows using the SACommand object@/olink@.</para>
        </remarks><seealso cref="M:iAnywhere.Data.SQLAnywhere.SAConnection.BeginTransaction"/><seealso cref="M:iAnywhere.Data.SQLAnywhere.SAConnection.BeginTransaction(iAnywhere.Data.SQLAnywhere.SAIsolationLevel)"/><seealso cref="P:iAnywhere.Data.SQLAnywhere.SACommand.Transaction"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SATransaction.Finalize">
            <summary>
            <para>Destructs an SATransaction object.</para>
        </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SATransaction.Commit">
            <summary>
            <para>Commits the database transaction.</para>
        </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SATransaction.Rollback">
            <summary>
            <para>Rolls back a transaction from a pending state.</para>
        </summary><remarks>
            <para>The transaction can only be rolled back from a pending state (after BeginTransaction has been called, but before Commit is called).</para>
        </remarks>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SATransaction.Rollback(System.String)">
            <summary>
            <para>Rolls back a transaction from a pending state.</para>
        </summary><remarks>
            <para>The transaction can only be rolled back from a pending state (after BeginTransaction has been called, but before Commit is called).</para>
        </remarks><param name="savePoint">
            The name of the savepoint to roll back to. 
        </param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SATransaction.Save(System.String)">
            <summary>
            <para>Creates a savepoint in the transaction that can be used to roll back a portion of the transaction, and specifies the savepoint name.</para>
        </summary><param name="savePoint">
            The name of the savepoint to which to roll back. 
        </param>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SATransaction.DbConnection">
            <summary>
            <para>Specifies the <see cref="T:System.Data.Common.DbConnection"/> object associated with the transaction.</para>
        </summary><returns>
	    <para>The <see cref="T:System.Data.Common.DbConnection"/> object associated with the transaction.</para>
        </returns>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SATransaction.Connection">
            <summary>
            <para>The SAConnection object associated with the transaction, or a null reference (Nothing in Visual Basic) if the transaction is no longer valid.</para>
        </summary><remarks>
            <para>A single application can have multiple database connections, each with zero or more transactions. This property enables you to determine the connection object associated with a particular transaction created by BeginTransaction.</para>
        </remarks>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SATransaction.IsolationLevel">
            <summary>
            <para>Specifies the isolation level for this transaction.</para>
        </summary><value>
		<para>The isolation level for this transaction. This can be one of: </para>
        <list type="bullet">
        <item>
        <term>ReadCommitted</term> 
        </item>
        <item>
        <term>ReadUncommitted</term> 
        </item>
        <item>
        <term>RepeatableRead</term> 
        </item>
        <item>
        <term>Serializable</term> 
        </item>
        <item>
        <term>Snapshot</term> 
        </item>
        <item>
        <term>ReadOnlySnapshot</term> 
        </item>
        <item>
        <term>StatementSnapshot</term> 
        </item>
        </list>
        <para>The default is ReadCommitted.</para>
        </value>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SATransaction.SAIsolationLevel">
            <summary>
            <para>Specifies the isolation level for this transaction.</para>
        </summary><value>
		<para>The IsolationLevel for this transaction. This can be one of: </para>
        <list type="bullet">
        <item>
        <term>Chaos</term> 
        </item>
        <item>
        Read <term>ReadCommitted</term> 
        </item>
        <item>
        <term>ReadOnlySnapshot</term> 
        </item>
        <item>
        <term>ReadUncommitted</term> 
        </item>
        <item>
        <term>RepeatableRead</term> 
        </item>
        <item>
        <term>Serializable</term> 
        </item>
        <item>
        <term>Snapshot</term> 
        </item>
        <item>
        <term>StatementSnapshot</term> 
        </item>
        <item>
        <term>Unspecified</term> 
        </item>
        </list>
        <para>The default is ReadCommitted.</para>
        </value><remarks>
            <para>Parallel transactions are not supported. Therefore, the IsolationLevel applies to the entire transaction.</para>
        </remarks>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SAUnmanagedDll">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SAUtility">
            @internal
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.DmlSqlGenerator">
            <summary>
            Class generating SQL for a DML command tree.
            </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.DmlSqlGenerator.GenerateReturningSql(System.Text.StringBuilder,System.Data.Common.CommandTrees.DbModificationCommandTree,iAnywhere.Data.SQLAnywhere.DmlSqlGenerator.ExpressionTranslator,System.Data.Common.CommandTrees.DbExpression)">
            <summary>
            Generates SQL fragment returning server-generated values.
            Requires: translator knows about member values so that we can figure out
            how to construct the key predicate.
            <code>
            Sample SQL:
                
                select IdentityValue
                from dbo.MyTable
                where @@ROWCOUNT > 0 and IdentityValue = @@identity
            
            or
            
                select TimestamptValue
                from dbo.MyTable
                where @@ROWCOUNT > 0 and Id = 1
            
            Note that we filter on rowcount to ensure no rows are returned if no rows were modified.
            </code>
            </summary>
            <param name="commandText">Builder containing command text</param>
            <param name="tree">Modification command tree</param>
            <param name="translator">Translator used to produce DML SQL statement
            for the tree</param>
            <param name="returning">Returning expression. If null, the method returns
            immediately without producing a SELECT statement.</param>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.DmlSqlGenerator.ExpressionTranslator">
            <summary>
            Lightweight expression translator for DML expression trees, which have constrained
            scope and support.
            </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.DmlSqlGenerator.ExpressionTranslator.#ctor(System.Text.StringBuilder,System.Data.Common.CommandTrees.DbModificationCommandTree,System.Boolean)">
            <summary>
            Initialize a new expression translator populating the given string builder
            with command text. Command text builder and command tree must not be null.
            </summary>
            <param name="commandText">Command text with which to populate commands</param>
            <param name="commandTree">Command tree generating SQL</param>
            <param name="preserveMemberValues">Indicates whether the translator should preserve
            member values while compiling t-SQL (only needed for server generation)</param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.DmlSqlGenerator.ExpressionTranslator.RegisterMemberValue(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)">
            <summary>
            Call this method to register a property value pair so the translator "remembers"
            the values for members of the row being modified. These values can then be used
            to form a predicate for server-generation (based on the key of the row)
            </summary>
            <param name="propertyExpression">DbExpression containing the column reference (property expression).</param>
            <param name="value">DbExpression containing the value of the column.</param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAProviderServices.GetParameterSize(System.Data.Metadata.Edm.TypeUsage,System.Boolean)">
            <summary>
            Determines preferred value for SqlParameter.Size. Returns null
            where there is no preference.
            </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAProviderServices.GetStringDbType(System.Data.Metadata.Edm.TypeUsage)">
            <summary>
            Chooses the appropriate SqlDbType for the given string type.
            </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SAProviderServices.GetBinaryDbType(System.Data.Metadata.Edm.TypeUsage)">
            <summary>
            Chooses the appropriate SqlDbType for the given binary type.
            </summary>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.ISqlFragment">
            <summary>
            Represents the sql fragment for any node in the query tree.
            </summary>
            <remarks>
            The nodes in a query tree produce various kinds of sql
            <list type="bullet">
            <item>A select statement.</item>
            <item>A reference to an extent. (symbol)</item>
            <item>A raw string.</item>
            </list>
            We have this interface to allow for a common return type for the methods
            in the expression visitor <see cref="T:System.Data.Common.CommandTrees.DbExpressionVisitor`1"/>
            
            At the end of translation, the sql fragments are converted into real strings.
            </remarks>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.ISqlFragment.WriteSql(iAnywhere.Data.SQLAnywhere.SqlWriter,iAnywhere.Data.SQLAnywhere.SqlGenerator)">
            <summary>
            Write the string represented by this fragment into the stream.
            </summary>
            <param name="writer">The stream that collects the strings.</param>
            <param name="sqlGenerator">Context information used for renaming.
            The global lists are used to generated new names without collisions.</param>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.JoinSymbol">
            <summary>
            A Join symbol is a special kind of Symbol.
            It has to carry additional information
            <list type="bullet">
            <item>ColumnList for the list of columns in the select clause if this
            symbol represents a sql select statement.  This is set by <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.AddDefaultColumns(iAnywhere.Data.SQLAnywhere.SqlSelectStatement)"/>. </item>
            <item>ExtentList is the list of extents in the select clause.</item>
            <item>FlattenedExtentList - if the Join has multiple extents flattened at the 
            top level, we need this information to ensure that extent aliases are renamed
            correctly in <see cref="M:iAnywhere.Data.SQLAnywhere.SqlSelectStatement.WriteSql(iAnywhere.Data.SQLAnywhere.SqlWriter,iAnywhere.Data.SQLAnywhere.SqlGenerator)"/></item>
            <item>NameToExtent has all the extents in ExtentList as a dictionary.
            This is used by <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbPropertyExpression)"/> to flatten
            record accesses.</item>
            <item>IsNestedJoin - is used to determine whether a JoinSymbol is an 
            ordinary join symbol, or one that has a corresponding SqlSelectStatement.</item>
            </list>
            
            All the lists are set exactly once, and then used for lookups/enumerated.
            </summary>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.Symbol">
             <summary>
             <see cref="T:iAnywhere.Data.SQLAnywhere.SymbolTable"/>
             This class represents an extent/nested select statement,
             or a column.
            
             The important fields are Name, Type and NewName.
             NewName starts off the same as Name, and is then modified as necessary.
            
            
             The rest are used by special symbols.
             e.g. NeedsRenaming is used by columns to indicate that a new name must
             be picked for the column in the second phase of translation.
            
             IsUnnest is used by symbols for a collection expression used as a from clause.
             This allows <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.AddFromSymbol(iAnywhere.Data.SQLAnywhere.SqlSelectStatement,System.String,iAnywhere.Data.SQLAnywhere.Symbol,System.Boolean)"/> to add the column list
             after the alias.
            
             </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.Symbol.WriteSql(iAnywhere.Data.SQLAnywhere.SqlWriter,iAnywhere.Data.SQLAnywhere.SqlGenerator)">
             <summary>
             Write this symbol out as a string for sql.  This is just
             the new name of the symbol (which could be the same as the old name).
            
             We rename columns here if necessary.
             </summary>
             <param name="writer"></param>
             <param name="sqlGenerator"></param>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.MetadataHelpers">
            <summary>
            A set of static helpers for type metadata
            </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.MetadataHelpers.NullableFacetName">
            <summary>
            Name of the Nullable Facet
            </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.MetadataHelpers.GetEdmType``1(System.Data.Metadata.Edm.TypeUsage)">
            <summary>
            Cast the EdmType of the given type usage to the given TEdmType
            </summary>
            <typeparam name="TEdmType"></typeparam>
            <param name="typeUsage"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.MetadataHelpers.GetElementTypeUsage(System.Data.Metadata.Edm.TypeUsage)">
            <summary>
            Gets the TypeUsage of the elment if the given type is a collection type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.MetadataHelpers.GetProperties(System.Data.Metadata.Edm.TypeUsage)">
            <summary>
            Retrieves the properties of in the EdmType underlying the input type usage, 
             if that EdmType is a structured type (EntityType, RowType). 
            </summary>
            <param name="typeUsage"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.MetadataHelpers.GetProperties(System.Data.Metadata.Edm.EdmType)">
            <summary>
            Retrieves the properties of the given EdmType, if it is
             a structured type (EntityType, RowType). 
            </summary>
            <param name="edmType"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.MetadataHelpers.IsCollectionType(System.Data.Metadata.Edm.TypeUsage)">
            <summary>
            Is the given type usage over a collection type
            </summary>
            <param name="typeUsage"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.MetadataHelpers.IsCollectionType(System.Data.Metadata.Edm.EdmType)">
            <summary>
            Is the given type a collection type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.MetadataHelpers.IsPrimitiveType(System.Data.Metadata.Edm.TypeUsage)">
            <summary>
            Is the given type usage over a primitive type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.MetadataHelpers.IsPrimitiveType(System.Data.Metadata.Edm.EdmType)">
            <summary>
            Is the given type a primitive type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.MetadataHelpers.IsRowType(System.Data.Metadata.Edm.TypeUsage)">
            <summary>
            Is the given type usage over a row type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.MetadataHelpers.IsRowType(System.Data.Metadata.Edm.EdmType)">
            <summary>
            Is the given type a row type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.MetadataHelpers.TryGetPrimitiveTypeKind(System.Data.Metadata.Edm.TypeUsage,System.Data.Metadata.Edm.PrimitiveTypeKind@)">
            <summary>
            Gets the type of the given type usage if it is a primitive type
            </summary>
            <param name="type"></param>
            <param name="typeKind"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.MetadataHelpers.TryGetValueForMetadataProperty``1(System.Data.Metadata.Edm.MetadataItem,System.String)">
            <summary>
            Gets the value for the metadata property with the given name
            </summary>
            <typeparam name="T"></typeparam>
            <param name="item"></param>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.MetadataHelpers.MaxLengthFacetName">
            <summary>
            Name of the MaxLength Facet
            </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.MetadataHelpers.UnicodeFacetName">
            <summary>
            Name of the Unicode Facet
            </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.MetadataHelpers.FixedLengthFacetName">
            <summary>
            Name of the FixedLength Facet
            </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.MetadataHelpers.PreserveSecondsFacetName">
            <summary>
            Name of the PreserveSeconds Facet
            </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.MetadataHelpers.PrecisionFacetName">
            <summary>
            Name of the Precision Facet
            </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.MetadataHelpers.ScaleFacetName">
            <summary>
            Name of the Scale Facet
            </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.MetadataHelpers.DefaultValueFacetName">
            <summary>
            Name of the DefaultValue Facet
            </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.MetadataHelpers.GetFacetValueOrDefault``1(System.Data.Metadata.Edm.TypeUsage,System.String,``0)">
            <summary>
            Get the value specified on the given type usage for the given facet name.
            If the faces does not have a value specifid or that value is null returns
            the default value for that facet.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="type"></param>
            <param name="facetName"></param>
            <returns></returns>
            <summary>
            Get the value specified on the given type usage for the given facet name.
            If the faces does not have a value specifid or that value is null returns
            the default value for that facet.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="type"></param>
            <param name="facetName"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.MetadataHelpers.TryGetTypeFacetDescriptionByName(System.Data.Metadata.Edm.EdmType,System.String,System.Data.Metadata.Edm.FacetDescription@)">
            <summary>
            Given a facet name and an EdmType, tries to get that facet's description.
            </summary>
            <param name="edmType"></param>
            <param name="facetName"></param>
            <param name="facetDescription"></param>
            <returns></returns>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SAProviderManifest">
            <summary>
            The Provider Manifest for SQL Anywhere
            </summary>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SqlBuilder">
            <summary>
            This class is like StringBuilder.  While traversing the tree for the first time, 
            we do not know all the strings that need to be appended e.g. things that need to be
            renamed, nested select statements etc.  So, we use a builder that can collect
            all kinds of sql fragments.
            </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlBuilder.Append(System.Object)">
            <summary>
            Add an object to the list - we do not verify that it is a proper sql fragment
            since this is an internal method.
            </summary>
            <param name="s"></param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlBuilder.Insert(System.Int32,System.Object)">
            <summary>
            Insert an object to the list
            </summary>
            <param name="index"></param>
            <param name="s"></param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlBuilder.AppendLine">
            <summary>
            This is to pretty print the SQL.  The writer <see cref="M:iAnywhere.Data.SQLAnywhere.SqlWriter.Write(System.String)"/>
            needs to know about new lines so that it can add the right amount of 
            indentation at the beginning of lines.
            </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlBuilder.WriteSql(iAnywhere.Data.SQLAnywhere.SqlWriter,iAnywhere.Data.SQLAnywhere.SqlGenerator)">
            <summary>
            We delegate the writing of the fragment to the appropriate type.
            </summary>
            <param name="writer"></param>
            <param name="sqlGenerator"></param>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SqlBuilder.IsEmpty">
            <summary>
            Whether the builder is empty.  This is used by the <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbProjectExpression)"/>
            to determine whether a sql statement can be reused.
            </summary>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SqlGenerator">
             <summary>
             Translates the command object into a SQL string that can be executed on
             SQL Server 2005.
             </summary>
             <remarks>
             The translation is implemented as a visitor <see cref="T:System.Data.Common.CommandTrees.DbExpressionVisitor`1"/>
             over the query tree.  It makes a single pass over the tree, collecting the sql
             fragments for the various nodes in the tree <see cref="T:iAnywhere.Data.SQLAnywhere.ISqlFragment"/>.
            
             The major operations are
             <list type="bullet">
             <item>Select statement minimization.  Multiple nodes in the query tree
             that can be part of a single SQL select statement are merged. e.g. a
             Filter node that is the input of a Project node can typically share the
             same SQL statement.</item>
             <item>Alpha-renaming.  As a result of the statement minimization above, there
             could be name collisions when using correlated subqueries
             <example>
             <code>
             Filter(
                 b = Project( c.x
                     c = Extent(foo)
                     )
                 exists (
                     Filter(
                         c = Extent(foo)
                         b.x = c.x
                         )
                 )
             )
             </code>
             The first Filter, Project and Extent will share the same SQL select statement.
             The alias for the Project i.e. b, will be replaced with c.
             If the alias c for the Filter within the exists clause is not renamed,
             we will get <c>c.x = c.x</c>, which is incorrect.
             Instead, the alias c within the second filter should be renamed to c1, to give
             <c>c.x = c1.x</c> i.e. b is renamed to c, and c is renamed to c1.
             </example>
             </item>
             <item>Join flattening.  In the query tree, a list of join nodes is typically
             represented as a tree of Join nodes, each with 2 children. e.g.
             <example>
             <code>
             a = Join(InnerJoin
                 b = Join(CrossJoin
                     c = Extent(foo)
                     d = Extent(foo)
                     )
                 e = Extent(foo)
                 on b.c.x = e.x
                 )
             </code>
             If translated directly, this will be translated to
             <code>
             FROM ( SELECT c.*, d.*
                     FROM foo as c
                     CROSS JOIN foo as d) as b
             INNER JOIN foo as e on b.x' = e.x
             </code>
             It would be better to translate this as
             <code>
             FROM foo as c
             CROSS JOIN foo as d
             INNER JOIN foo as e on c.x = e.x
             </code>
             This allows the optimizer to choose an appropriate join ordering for evaluation.
             </example>
             </item>
             <item>Select * and column renaming.  In the example above, we noticed that
             in some cases we add <c>SELECT * FROM ...</c> to complete the SQL
             statement. i.e. there is no explicit PROJECT list.
             In this case, we enumerate all the columns available in the FROM clause
             This is particularly problematic in the case of Join trees, since the columns
             from the extents joined might have the same name - this is illegal.  To solve
             this problem, we will have to rename columns if they are part of a SELECT *
             for a JOIN node - we do not need renaming in any other situation.
             <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.AddDefaultColumns(iAnywhere.Data.SQLAnywhere.SqlSelectStatement)"/>.
             </item>
             </list>
            
             <para>
             Renaming issues.
             When rows or columns are renamed, we produce names that are unique globally
             with respect to the query.  The names are derived from the original names,
             with an integer as a suffix. e.g. CustomerId will be renamed to CustomerId1,
             CustomerId2 etc.
            
             Since the names generated are globally unique, they will not conflict when the
             columns of a JOIN SELECT statement are joined with another JOIN. 
            
             </para>
            
             <para>
             Record flattening.
             SQL server does not have the concept of records.  However, a join statement
             produces records.  We have to flatten the record accesses into a simple
             <c>alias.column</c> form.  <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbPropertyExpression)"/>
             </para>
            
             <para>
             Building the SQL.
             There are 2 phases
             <list type="numbered">
             <item>Traverse the tree, producing a sql builder <see cref="T:iAnywhere.Data.SQLAnywhere.SqlBuilder"/></item>
             <item>Write the SqlBuilder into a string, renaming the aliases and columns
             as needed.</item>
             </list>
            
             In the first phase, we traverse the tree.  We cannot generate the SQL string
             right away, since
             <list type="bullet">
             <item>The WHERE clause has to be visited before the from clause.</item>
             <item>extent aliases and column aliases need to be renamed.  To minimize
             renaming collisions, all the names used must be known, before any renaming
             choice is made.</item>
             </list>
             To defer the renaming choices, we use symbols <see cref="T:iAnywhere.Data.SQLAnywhere.Symbol"/>.  These
             are renamed in the second phase.
            
             Since visitor methods cannot transfer information to child nodes through
             parameters, we use some global stacks,
             <list type="bullet">
             <item>A stack for the current SQL select statement.  This is needed by
             <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbVariableReferenceExpression)"/> to create a
             list of free variables used by a select statement.  This is needed for
             alias renaming.
             </item>
             <item>A stack for the join context.  When visiting a <see cref="T:System.Data.Common.CommandTrees.DbScanExpression"/>,
             we need to know whether we are inside a join or not.  If we are inside
             a join, we do not create a new SELECT statement.</item>
             </list>
             </para>
            
             <para>
             Global state.
             To enable renaming, we maintain
             <list type="bullet">
             <item>The set of all extent aliases used.</item>
             <item>The set of all column aliases used.</item>
             </list>
            
             Finally, we have a symbol table to lookup variable references.  All references
             to the same extent have the same symbol.
             </para>
            
             <para>
             Sql select statement sharing.
            
             Each of the relational operator nodes
             <list type="bullet">
             <item>Project</item>
             <item>Filter</item>
             <item>GroupBy</item>
             <item>Sort/OrderBy</item>
             </list>
             can add its non-input (e.g. project, predicate, sort order etc.) to
             the SQL statement for the input, or create a new SQL statement.
             If it chooses to reuse the input's SQL statement, we play the following
             symbol table trick to accomplish renaming.  The symbol table entry for
             the alias of the current node points to the symbol for the input in
             the input's SQL statement.
             <example>
             <code>
             Project(b.x
                 b = Filter(
                     c = Extent(foo)
                     c.x = 5)
                 )
             </code>
             The Extent node creates a new SqlSelectStatement.  This is added to the
             symbol table by the Filter as {c, Symbol(c)}.  Thus, <c>c.x</c> is resolved to
             <c>Symbol(c).x</c>.
             Looking at the project node, we add {b, Symbol(c)} to the symbol table if the
             SQL statement is reused, and {b, Symbol(b)}, if there is no reuse.
            
             Thus, <c>b.x</c> is resolved to <c>Symbol(c).x</c> if there is reuse, and to
             <c>Symbol(b).x</c> if there is no reuse.
             </example>
             </para>
             </remarks>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SqlGenerator.selectStatementStack">
            <summary>
            Every relational node has to pass its SELECT statement to its children
            This allows them (DbVariableReferenceExpression eventually) to update the list of
            outer extents (free variables) used by this select statement.
            </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SqlGenerator.isParentAJoinStack">
            <summary>
            Nested joins and extents need to know whether they should create
            a new Select statement, or reuse the parent's.  This flag
            indicates whether the parent is a join or not.
            </summary>
        </member>
        <member name="F:iAnywhere.Data.SQLAnywhere.SqlGenerator.isVarRefSingle">
            <summary>
            VariableReferenceExpressions are allowed only as children of DbPropertyExpression
            or MethodExpression.  The cheapest way to ensure this is to set the following
            property in DbVariableReferenceExpression and reset it in the allowed parent expressions.
            </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.InitializeBuiltInFunctionHandlers">
            <summary>
            All special built-in functions and their handlers
            </summary>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.InitializeCanonicalFunctionHandlers">
            <summary>
            All special non-aggregate canonical functions and their handlers
            </summary>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.InitializeDatepartKeywords">
            <summary>
            Valid datepart values
            </summary>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.InitializeFunctionNameToOperatorDictionary">
            <summary>
            Initializes the mapping from functions to T-SQL operators
            for all functions that translate to T-SQL operators
            </summary>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.#ctor">
            <summary>
            Basic constructor. 
            </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.GenerateSql(System.Data.Common.CommandTrees.DbCommandTree,System.Collections.Generic.List{System.Data.Common.DbParameter}@,System.Data.CommandType@)">
            <summary>
            General purpose static function that can be called from System.Data assembly
            </summary>
            <param name="sqlVersion">Server version</param>
            <param name="tree">command tree</param>
            <param name="parameters">Parameters to add to the command tree corresponding
            to constants in the command tree. Used only in ModificationCommandTrees.</param>
            <returns>The string representing the SQL to be executed.</returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.GenerateSql(System.Data.Common.CommandTrees.DbQueryCommandTree)">
             <summary>
             Translate a command tree to a SQL string.
            
             The input tree could be translated to either a SQL SELECT statement
             or a SELECT expression.  This choice is made based on the return type
             of the expression
             CollectionType => select statement
             non collection type => select expression
             </summary>
             <param name="tree"></param>
             <returns>The string representing the SQL to be executed.</returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.GenerateFunctionSql(System.Data.Common.CommandTrees.DbFunctionCommandTree,System.Data.CommandType@)">
            <summary>
            Translate a function command tree to a SQL string.
            </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.WriteSql(iAnywhere.Data.SQLAnywhere.ISqlFragment)">
            <summary>
            Convert the SQL fragments to a string.
            We have to setup the Stream for writing.
            </summary>
            <param name="sqlStatement"></param>
            <returns>A string representing the SQL to be executed.</returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbAndExpression)">
            <summary>
            Translate(left) AND Translate(right)
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:iAnywhere.Data.SQLAnywhere.SqlBuilder"/>.</returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbApplyExpression)">
            <summary>
            An apply is just like a join, so it shares the common join processing
            in <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.VisitJoinExpression(System.Collections.Generic.IList{System.Data.Common.CommandTrees.DbExpressionBinding},System.Data.Common.CommandTrees.DbExpressionKind,System.String,System.Data.Common.CommandTrees.DbExpression)"/>
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:iAnywhere.Data.SQLAnywhere.SqlSelectStatement"/>.</returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbArithmeticExpression)">
            <summary>
            For binary expressions, we delegate to <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.VisitBinaryExpression(System.String,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)"/>.
            We handle the other expressions directly.
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:iAnywhere.Data.SQLAnywhere.SqlBuilder"/></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbCaseExpression)">
            <summary>
            If the ELSE clause is null, we do not write it out.
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:iAnywhere.Data.SQLAnywhere.SqlBuilder"/></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbCastExpression)">
             <summary>
            
             </summary>
             <param name="e"></param>
             <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbComparisonExpression)">
            <summary>
            The parser generates Not(Equals(...)) for &lt;&gt;.
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:iAnywhere.Data.SQLAnywhere.SqlBuilder"/>.</returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbConstantExpression)">
            <summary>
            Constants will be send to the store as part of the generated TSQL, not as parameters
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:iAnywhere.Data.SQLAnywhere.SqlBuilder"/>.  Strings are wrapped in single
            quotes and escaped.  Numbers are written literally.</returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbDerefExpression)">
            <summary>
            <see cref="T:System.Data.Common.CommandTrees.DbDerefExpression"/> is illegal at this stage
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbDistinctExpression)">
            <summary>
            The DISTINCT has to be added to the beginning of SqlSelectStatement.Select,
            but it might be too late for that.  So, we use a flag on SqlSelectStatement
            instead, and add the "DISTINCT" in the second phase.
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:iAnywhere.Data.SQLAnywhere.SqlSelectStatement"/></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbElementExpression)">
            <summary>
            An element expression returns a scalar - so it is translated to
            ( Select ... )
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbExceptExpression)">
            <summary>
            <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbUnionAllExpression)"/>
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbExpression)">
            <summary>
            Only concrete expression types will be visited.
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbScanExpression)">
             <summary>
            
             </summary>
             <param name="e"></param>
             <returns>If we are in a Join context, returns a <see cref="T:iAnywhere.Data.SQLAnywhere.SqlBuilder"/>
             with the extent name, otherwise, a new <see cref="T:iAnywhere.Data.SQLAnywhere.SqlSelectStatement"/>
             with the From field set.</returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.GetTargetTSql(System.Data.Metadata.Edm.EntitySetBase)">
            <summary>
            Gets escaped TSql identifier describing this entity set.
            </summary>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbFilterExpression)">
            <summary>
            The bodies of <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbFilterExpression)"/>, <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbGroupByExpression)"/>,
            <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbProjectExpression)"/>, <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbSortExpression)"/> are similar.
            Each does the following.
            <list type="number">
            <item> Visit the input expression</item>
            <item> Determine if the input's SQL statement can be reused, or a new
            one must be created.</item>
            <item>Create a new symbol table scope</item>
            <item>Push the Sql statement onto a stack, so that children can
            update the free variable list.</item>
            <item>Visit the non-input expression.</item>
            <item>Cleanup</item>
            </list>
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:iAnywhere.Data.SQLAnywhere.SqlSelectStatement"/></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            Lambda functions are not supported.
            The functions supported are:
            <list type="number">
            <item>Canonical Functions - We recognize these by their dataspace, it is DataSpace.CSpace</item>
            <item>Store Functions - We recognize these by the BuiltInAttribute and not being Canonical</item>
            <item>User-defined Functions - All the rest except for Lambda functions</item>
            </list>
            We handle Canonical and Store functions the same way: If they are in the list of functions 
            that need special handling, we invoke the appropriate handler, otherwise we translate them to
            FunctionName(arg1, arg2, ..., argn).
            We translate user-defined functions to NamespaceName.FunctionName(arg1, arg2, ..., argn).
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:iAnywhere.Data.SQLAnywhere.SqlBuilder"/></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbEntityRefExpression)">
            <summary>
            <see cref="T:System.Data.Common.CommandTrees.DbEntityRefExpression"/> is illegal at this stage
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbRefKeyExpression)">
            <summary>
            <see cref="T:System.Data.Common.CommandTrees.DbRefKeyExpression"/> is illegal at this stage
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbGroupByExpression)">
            <summary>
            <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbFilterExpression)"/> for general details.
            We modify both the GroupBy and the Select fields of the SqlSelectStatement.
            GroupBy gets just the keys without aliases,
            and Select gets the keys and the aggregates with aliases.
            
            Whenever there exists at least one aggregate with an argument that is not is not a simple
            <see cref="T:System.Data.Common.CommandTrees.DbPropertyExpression"/>  over <see cref="T:System.Data.Common.CommandTrees.DbVariableReferenceExpression"/>, 
            we create a nested query in which we alias the arguments to the aggregates. 
            That is due to the following two limitations of Sql Server:
            <list type="number">
            <item>If an expression being aggregated contains an outer reference, then that outer 
            reference must be the only column referenced in the expression </item>
            <item>Sql Server cannot perform an aggregate function on an expression containing 
            an aggregate or a subquery. </item>
            </list>
            
            The default translation, without inner query is: 
            
                SELECT 
                    kexp1 AS key1, kexp2 AS key2,... kexpn AS keyn, 
                    aggf1(aexpr1) AS agg1, .. aggfn(aexprn) AS aggn
                FROM input AS a
                GROUP BY kexp1, kexp2, .. kexpn
            
            When we inject an innner query, the equivalent translation is:
            
                SELECT 
                    key1 AS key1, key2 AS key2, .. keyn AS keys,  
                    aggf1(agg1) AS agg1, aggfn(aggn) AS aggn
                FROM (
                        SELECT 
                            kexp1 AS key1, kexp2 AS key2,... kexpn AS keyn, 
                            aexpr1 AS agg1, .. aexprn AS aggn
                        FROM input AS a
                    ) as a
                GROUP BY key1, key2, keyn
            
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:iAnywhere.Data.SQLAnywhere.SqlSelectStatement"/></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbIntersectExpression)">
            <summary>
            <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbUnionAllExpression)"/>
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbIsEmptyExpression)">
             <summary>
             Not(IsEmpty) has to be handled specially, so we delegate to
             <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.VisitIsEmptyExpression(System.Data.Common.CommandTrees.DbIsEmptyExpression,System.Boolean)"/>.
            
             </summary>
             <param name="e"></param>
             <returns>A <see cref="T:iAnywhere.Data.SQLAnywhere.SqlBuilder"/>.
             <code>[NOT] EXISTS( ... )</code>
             </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbIsNullExpression)">
            <summary>
            Not(IsNull) is handled specially, so we delegate to
            <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.VisitIsNullExpression(System.Data.Common.CommandTrees.DbIsNullExpression,System.Boolean)"/>
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:iAnywhere.Data.SQLAnywhere.SqlBuilder"/>
            <code>IS [NOT] NULL</code>
            </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbIsOfExpression)">
            <summary>
            <see cref="T:System.Data.Common.CommandTrees.DbIsOfExpression"/> is illegal at this stage
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:iAnywhere.Data.SQLAnywhere.SqlBuilder"/></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbCrossJoinExpression)">
            <summary>
            <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.VisitJoinExpression(System.Collections.Generic.IList{System.Data.Common.CommandTrees.DbExpressionBinding},System.Data.Common.CommandTrees.DbExpressionKind,System.String,System.Data.Common.CommandTrees.DbExpression)"/>
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:iAnywhere.Data.SQLAnywhere.SqlSelectStatement"/>.</returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbJoinExpression)">
            <summary>
            <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.VisitJoinExpression(System.Collections.Generic.IList{System.Data.Common.CommandTrees.DbExpressionBinding},System.Data.Common.CommandTrees.DbExpressionKind,System.String,System.Data.Common.CommandTrees.DbExpression)"/>
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:iAnywhere.Data.SQLAnywhere.SqlSelectStatement"/>.</returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbLikeExpression)">
             <summary>
            
             </summary>
             <param name="e"></param>
             <returns>A <see cref="T:iAnywhere.Data.SQLAnywhere.SqlBuilder"/></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbLimitExpression)">
            <summary>
             Translates to TOP expression.
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:iAnywhere.Data.SQLAnywhere.SqlBuilder"/></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbNewInstanceExpression)">
             <summary>
             DbNewInstanceExpression is allowed as a child of DbProjectExpression only.
             If anyone else is the parent, we throw.
             We also perform special casing for collections - where we could convert
             them into Unions
            
             <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.VisitNewInstanceExpression(System.Data.Common.CommandTrees.DbNewInstanceExpression)"/> for the actual implementation.
            
             </summary>
             <param name="e"></param>
             <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbNotExpression)">
            <summary>
            The Not expression may cause the translation of its child to change.
            These children are
            <list type="bullet">
            <item><see cref="T:System.Data.Common.CommandTrees.DbNotExpression"/>NOT(Not(x)) becomes x</item>
            <item><see cref="T:System.Data.Common.CommandTrees.DbIsEmptyExpression"/>NOT EXISTS becomes EXISTS</item>
            <item><see cref="T:System.Data.Common.CommandTrees.DbIsNullExpression"/>IS NULL becomes IS NOT NULL</item>
            <item><see cref="T:System.Data.Common.CommandTrees.DbComparisonExpression"/>= becomes&lt;&gt; </item>
            </list>
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:iAnywhere.Data.SQLAnywhere.SqlBuilder"/></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbNullExpression)">
            <summary>
            </summary>
            <param name="e"></param>
            <returns><see cref="T:iAnywhere.Data.SQLAnywhere.SqlBuilder"/></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbOfTypeExpression)">
            <summary>
            <see cref="T:System.Data.Common.CommandTrees.DbOfTypeExpression"/> is illegal at this stage
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:iAnywhere.Data.SQLAnywhere.SqlBuilder"/></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbOrExpression)">
             <summary>
            
             </summary>
             <param name="e"></param>
             <returns>A <see cref="T:iAnywhere.Data.SQLAnywhere.SqlBuilder"/></returns>
             <seealso cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbAndExpression)"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbParameterReferenceExpression)">
             <summary>
            
             </summary>
             <param name="e"></param>
             <returns>A <see cref="T:iAnywhere.Data.SQLAnywhere.SqlBuilder"/></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbProjectExpression)">
            <summary>
            <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbFilterExpression)"/> for the general ideas.
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:iAnywhere.Data.SQLAnywhere.SqlSelectStatement"/></returns>
            <seealso cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbFilterExpression)"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbPropertyExpression)">
             <summary>
             This method handles record flattening, which works as follows.
             consider an expression <c>Prop(y, Prop(x, Prop(d, Prop(c, Prop(b, Var(a)))))</c>
             where a,b,c are joins, d is an extent and x and y are fields.
             b has been flattened into a, and has its own SELECT statement.
             c has been flattened into b.
             d has been flattened into c.
            
             We visit the instance, so we reach Var(a) first.  This gives us a (join)symbol.
             Symbol(a).b gives us a join symbol, with a SELECT statement i.e. Symbol(b).
             From this point on , we need to remember Symbol(b) as the source alias,
             and then try to find the column.  So, we use a SymbolPair.
            
             We have reached the end when the symbol no longer points to a join symbol.
             </summary>
             <param name="e"></param>
             <returns>A <see cref="T:iAnywhere.Data.SQLAnywhere.JoinSymbol"/> if we have not reached the first
             Join node that has a SELECT statement.
             A <see cref="T:iAnywhere.Data.SQLAnywhere.SymbolPair"/> if we have seen the JoinNode, and it has
             a SELECT statement.
             A <see cref="T:iAnywhere.Data.SQLAnywhere.SqlBuilder"/> with {Input}.propertyName otherwise.
             </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbQuantifierExpression)">
            <summary>
            Any(input, x) => Exists(Filter(input,x))
            All(input, x) => Not Exists(Filter(input, not(x))
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbRefExpression)">
            <summary>
            <see cref="T:System.Data.Common.CommandTrees.DbRefExpression"/> is illegal at this stage
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbRelationshipNavigationExpression)">
            <summary>
            <see cref="T:System.Data.Common.CommandTrees.DbRelationshipNavigationExpression"/> is illegal at this stage
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbSkipExpression)">
            <summary>
            NEW, efficient sql generator for Skip(e.Count). 
            Sql9  should  be translated to:
            SELECT Y.x1, Y.x2, ..., Y.xn
            FROM (
                SELECT TOP int32  START AT e.Count X.x1, X.x2, ..., X.xn 
                FROM (input) as X 
                ORDER BY sk1, sk2, ...
             ) as Y
            ORDER BY sk1, sk2, ...
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:iAnywhere.Data.SQLAnywhere.SqlBuilder"/></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbSortExpression)">
            <summary>
            <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbFilterExpression)"/>
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:iAnywhere.Data.SQLAnywhere.SqlSelectStatement"/></returns>
            <seealso cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbFilterExpression)"/>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbTreatExpression)">
            <summary>
            <see cref="T:System.Data.Common.CommandTrees.DbTreatExpression"/> is illegal at this stage
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:iAnywhere.Data.SQLAnywhere.SqlBuilder"/></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbUnionAllExpression)">
             <summary>
             This code is shared by <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbExceptExpression)"/>
             and <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbIntersectExpression)"/>
            
             <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.VisitSetOpExpression(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.String)"/>
             Since the left and right expression may not be Sql select statements,
             we must wrap them up to look like SQL select statements.
             </summary>
             <param name="e"></param>
             <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbVariableReferenceExpression)">
             <summary>
             This method determines whether an extent from an outer scope(free variable)
             is used in the CurrentSelectStatement.
            
             An extent in an outer scope, if its symbol is not in the FromExtents
             of the CurrentSelectStatement.
             </summary>
             <param name="e"></param>
             <returns>A <see cref="T:iAnywhere.Data.SQLAnywhere.Symbol"/>.</returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.VisitAggregate(System.Data.Common.CommandTrees.DbAggregate,System.Object)">
            <summary>
            Aggregates are not visited by the normal visitor walk.
            </summary>
            <param name="aggregate">The aggreate go be translated</param>
            <param name="aggregateArgument">The translated aggregate argument</param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.VisitInputExpression(System.Data.Common.CommandTrees.DbExpression,System.String,System.Data.Metadata.Edm.TypeUsage,iAnywhere.Data.SQLAnywhere.Symbol@)">
            <summary>
            This is called by the relational nodes.  It does the following
            <list>
            <item>If the input is not a SqlSelectStatement, it assumes that the input
            is a collection expression, and creates a new SqlSelectStatement </item>
            </list>
            </summary>
            <param name="inputExpression"></param>
            <param name="inputVarName"></param>
            <param name="inputVarType"></param>
            <param name="fromSymbol"></param>
            <returns>A <see cref="T:iAnywhere.Data.SQLAnywhere.SqlSelectStatement"/> and the main fromSymbol
            for this select statement.</returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.VisitIsEmptyExpression(System.Data.Common.CommandTrees.DbIsEmptyExpression,System.Boolean)">
            <summary>
            <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbIsEmptyExpression)"/>
            </summary>
            <param name="e"></param>
            <param name="negate">Was the parent a DbNotExpression?</param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.VisitCollectionConstructor(System.Data.Common.CommandTrees.DbNewInstanceExpression)">
            <summary>
            Translate a NewInstance(Element(X)) expression into
              "select top(1) * from X"
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.VisitIsNullExpression(System.Data.Common.CommandTrees.DbIsNullExpression,System.Boolean)">
            <summary>
            <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbIsNullExpression)"/>
            </summary>
            <param name="e"></param>
            <param name="negate">Was the parent a DbNotExpression?</param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.VisitJoinExpression(System.Collections.Generic.IList{System.Data.Common.CommandTrees.DbExpressionBinding},System.Data.Common.CommandTrees.DbExpressionKind,System.String,System.Data.Common.CommandTrees.DbExpression)">
             <summary>
             This handles the processing of join expressions.
             The extents on a left spine are flattened, while joins
             not on the left spine give rise to new nested sub queries.
            
             Joins work differently from the rest of the visiting, in that
             the parent (i.e. the join node) creates the SqlSelectStatement
             for the children to use.
            
             The "parameter" IsInJoinContext indicates whether a child extent should
             add its stuff to the existing SqlSelectStatement, or create a new SqlSelectStatement
             By passing true, we ask the children to add themselves to the parent join,
             by passing false, we ask the children to create new Select statements for
             themselves.
            
             This method is called from <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbApplyExpression)"/> and
             <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbJoinExpression)"/>.
             </summary>
             <param name="inputs"></param>
             <param name="joinKind"></param>
             <param name="joinString"></param>
             <param name="joinCondition"></param>
             <returns> A <see cref="T:iAnywhere.Data.SQLAnywhere.SqlSelectStatement"/></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.ProcessJoinInputResult(iAnywhere.Data.SQLAnywhere.ISqlFragment,iAnywhere.Data.SQLAnywhere.SqlSelectStatement,System.Data.Common.CommandTrees.DbExpressionBinding,System.Int32)">
             <summary>
             This is called from <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.VisitJoinExpression(System.Collections.Generic.IList{System.Data.Common.CommandTrees.DbExpressionBinding},System.Data.Common.CommandTrees.DbExpressionKind,System.String,System.Data.Common.CommandTrees.DbExpression)"/>.
            
             This is responsible for maintaining the symbol table after visiting
             a child of a join expression.
            
             The child's sql statement may need to be completed.
            
             The child's result could be one of
             <list type="number">
             <item>The same as the parent's - this is treated specially.</item>
             <item>A sql select statement, which may need to be completed</item>
             <item>An extent - just copy it to the from clause</item>
             <item>Anything else (from a collection-valued expression) -
             unnest and copy it.</item>
             </list>
            
             If the input was a Join, we need to create a new join symbol,
             otherwise, we create a normal symbol.
            
             We then call AddFromSymbol to add the AS clause, and update the symbol table.
            
            
            
             If the child's result was the same as the parent's, we have to clean up
             the list of symbols in the FromExtents list, since this contains symbols from
             the children of both the parent and the child.
             The happens when the child visited is a Join, and is the leftmost child of
             the parent.
             </summary>
             <param name="fromExtentFragment"></param>
             <param name="result"></param>
             <param name="input"></param>
             <param name="fromSymbolStart"></param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.VisitNewInstanceExpression(System.Data.Common.CommandTrees.DbNewInstanceExpression)">
            <returns>A <see cref="T:iAnywhere.Data.SQLAnywhere.SqlBuilder"/></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.IsSpecialBuiltInFunction(System.Data.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            Determines whether the given function is a built-in function that requires special handling
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.IsSpecialCanonicalFunction(System.Data.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            Determines whether the given function is a canonical function that requires special handling
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.HandleFunctionDefault(System.Data.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            Default handling for functions
            Translates them to FunctionName(arg1, arg2, ..., argn)
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.HandleFunctionDefaultGivenName(System.Data.Common.CommandTrees.DbFunctionExpression,System.String)">
            <summary>
            Default handling for functions with a given name.
            Translates them to functionName(arg1, arg2, ..., argn)
            </summary>
            <param name="e"></param>
            <param name="functionName"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.HandleFunctionArgumentsDefault(System.Data.Common.CommandTrees.DbFunctionExpression,iAnywhere.Data.SQLAnywhere.SqlBuilder)">
            <summary>
            Default handling on function arguments
            Appends the list of arguments to the given result
            If the function is niladic it does not append anything,
            otherwise it appends (arg1, arg2, ..., argn)
            </summary>
            <param name="e"></param>
            <param name="result"></param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.HandleSpecialBuiltInFunction(System.Data.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            Handler for special built in functions
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.HandleSpecialCanonicalFunction(System.Data.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            Handler for special canonical functions
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.HandleSpecialFunction(System.Collections.Generic.Dictionary{System.String,iAnywhere.Data.SQLAnywhere.SqlGenerator.FunctionHandler},System.Data.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            Dispatches the special function processing to the appropriate handler
            </summary>
            <param name="handlers"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.HandleSpecialFunctionToOperator(System.Data.Common.CommandTrees.DbFunctionExpression,System.Boolean)">
            <summary>
            Handles functions that are translated into TSQL operators.
            The given function should have one or two arguments. 
            Functions with one arguemnt are translated into 
                op arg
            Functions with two arguments are translated into
                arg0 op arg1
            Also, the arguments can be optionaly enclosed in parethesis
            </summary>
            <param name="e"></param>
            <param name="parenthesiseArguments">Whether the arguments should be enclosed in parethesis</param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.HandleConcatFunction(iAnywhere.Data.SQLAnywhere.SqlGenerator,System.Data.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.HandleSpecialFunctionToOperator(System.Data.Common.CommandTrees.DbFunctionExpression,System.Boolean)"></see>
            </summary>
            <param name="sqlgen"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.HandleCanonicalFunctionBitwise(iAnywhere.Data.SQLAnywhere.SqlGenerator,System.Data.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.HandleSpecialFunctionToOperator(System.Data.Common.CommandTrees.DbFunctionExpression,System.Boolean)"></see>
            </summary>
            <param name="sqlgen"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.HandleDatepartDateFunction(iAnywhere.Data.SQLAnywhere.SqlGenerator,System.Data.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            Handles special case in which datapart 'type' parameter is present. all the functions
            handles here have *only* the 1st parameter as datepart. datepart value is passed along
            the QP as string and has to be expanded as TSQL keyword.
            </summary>
            <param name="sqlgen"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.HandleCanonicalFunctionDateAdd(iAnywhere.Data.SQLAnywhere.SqlGenerator,System.Data.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            DateAdd(datetime, secondsToAdd) -> DATEADD ( seconds , number,  date)
            </summary>
            <param name="sqlgen"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.HandleCanonicalFunctionDateSubtract(iAnywhere.Data.SQLAnywhere.SqlGenerator,System.Data.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            DateSubtract(datetime1, datetime2) -> DATEDIFF ( seconds , startdate , enddate ) 
            </summary>
            <param name="sqlgen"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.HandleCanonicalFunctionDateDiff(iAnywhere.Data.SQLAnywhere.SqlGenerator,System.Data.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            DiffDays(datetime1, datetime2) -> DATEDIFF( day, datetime1 , datetime2 ) 
            </summary>
            <param name="sqlgen"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.HandleCanonicalFunctionDateAddNew(iAnywhere.Data.SQLAnywhere.SqlGenerator,System.Data.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            AddDays(datetime, int) -> DATEADD( day, datetime, int ) 
            </summary>
            <param name="sqlgen"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.HandleCanonicalFunctionDatepart(iAnywhere.Data.SQLAnywhere.SqlGenerator,System.Data.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            Handler for canonical funcitons for extracting date parts. 
            For example:
                Year(date) -> DATEPART( year, date)
            </summary>
            <param name="sqlgen"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.HandleCanonicalFunctionIndexOf(iAnywhere.Data.SQLAnywhere.SqlGenerator,System.Data.Common.CommandTrees.DbFunctionExpression)">
            <summary>
             Function rename IndexOf -> CHARINDEX
            </summary>
            <param name="sqlgen"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.HandleCanonicalFunctionNewGuid(iAnywhere.Data.SQLAnywhere.SqlGenerator,System.Data.Common.CommandTrees.DbFunctionExpression)">
            <summary>
             Function rename NewGuid -> NEWID
            </summary>
            <param name="sqlgen"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.HandleCanonicalFunctionLength(iAnywhere.Data.SQLAnywhere.SqlGenerator,System.Data.Common.CommandTrees.DbFunctionExpression)">
            <summary>
             Length(arg) -> LENGTH(arg)
            </summary>
            <param name="sqlgen"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.HandleCanonicalFunctionRound(iAnywhere.Data.SQLAnywhere.SqlGenerator,System.Data.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            Round(numericExpression) -> Round(numericExpression, 0);
            </summary>
            <param name="sqlgen"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.HandleCanonicalFunctionTrim(iAnywhere.Data.SQLAnywhere.SqlGenerator,System.Data.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            TRIM(string) -> LTRIM(RTRIM(string))
            </summary>
            <param name="sqlgen"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.HandleCanonicalFunctionToLower(iAnywhere.Data.SQLAnywhere.SqlGenerator,System.Data.Common.CommandTrees.DbFunctionExpression)">
            <summary>
             Function rename ToLower -> LOWER
            </summary>
            <param name="sqlgen"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.HandleCanonicalFunctionToUpper(iAnywhere.Data.SQLAnywhere.SqlGenerator,System.Data.Common.CommandTrees.DbFunctionExpression)">
            <summary>
             Function rename ToUpper -> UPPER
            </summary>
            <param name="sqlgen"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.AddColumns(iAnywhere.Data.SQLAnywhere.SqlSelectStatement,iAnywhere.Data.SQLAnywhere.Symbol,System.Collections.Generic.List{iAnywhere.Data.SQLAnywhere.Symbol},System.Collections.Generic.Dictionary{System.String,iAnywhere.Data.SQLAnywhere.Symbol},System.String@)">
             <summary>
             <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.AddDefaultColumns(iAnywhere.Data.SQLAnywhere.SqlSelectStatement)"/>
             Add the column names from the referenced extent/join to the
             select statement.
            
             If the symbol is a JoinSymbol, we recursively visit all the extents,
             halting at real extents and JoinSymbols that have an associated SqlSelectStatement.
            
             The column names for a real extent can be derived from its type.
             The column names for a Join Select statement can be got from the
             list of columns that was created when the Join's select statement
             was created.
            
             We do the following for each column.
             <list type="number">
             <item>Add the SQL string for each column to the SELECT clause</item>
             <item>Add the column to the list of columns - so that it can
             become part of the "type" of a JoinSymbol</item>
             <item>Check if the column name collides with a previous column added
             to the same select statement.  Flag both the columns for renaming if true.</item>
             <item>Add the column to a name lookup dictionary for collision detection.</item>
             </list>
             </summary>
             <param name="selectStatement">The select statement that started off as SELECT *</param>
             <param name="symbol">The symbol containing the type information for
             the columns to be added.</param>
             <param name="columnList">Columns that have been added to the Select statement.
             This is created in <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.AddDefaultColumns(iAnywhere.Data.SQLAnywhere.SqlSelectStatement)"/>.</param>
             <param name="columnDictionary">A dictionary of the columns above.</param>
             <param name="separator">Comma or nothing, depending on whether the SELECT
             clause is empty.</param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.AddDefaultColumns(iAnywhere.Data.SQLAnywhere.SqlSelectStatement)">
             <summary>
             Expands Select * to "select the_list_of_columns"
             If the columns are taken from an extent, they are written as
             {original_column_name AS Symbol(original_column)} to allow renaming.
            
             If the columns are taken from a Join, they are written as just
             {original_column_name}, since there cannot be a name collision.
            
             We concatenate the columns from each of the inputs to the select statement.
             Since the inputs may be joins that are flattened, we need to recurse.
             The inputs are inferred from the symbols in FromExtents.
             </summary>
             <param name="selectStatement"></param>
             <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.AddFromSymbol(iAnywhere.Data.SQLAnywhere.SqlSelectStatement,System.String,iAnywhere.Data.SQLAnywhere.Symbol)">
            <summary>
            <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.AddFromSymbol(iAnywhere.Data.SQLAnywhere.SqlSelectStatement,System.String,iAnywhere.Data.SQLAnywhere.Symbol,System.Boolean)"/>
            </summary>
            <param name="selectStatement"></param>
            <param name="inputVarName"></param>
            <param name="fromSymbol"></param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.AddFromSymbol(iAnywhere.Data.SQLAnywhere.SqlSelectStatement,System.String,iAnywhere.Data.SQLAnywhere.Symbol,System.Boolean)">
             <summary>
             This method is called after the input to a relational node is visited.
             <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbProjectExpression)"/> and <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.ProcessJoinInputResult(iAnywhere.Data.SQLAnywhere.ISqlFragment,iAnywhere.Data.SQLAnywhere.SqlSelectStatement,System.Data.Common.CommandTrees.DbExpressionBinding,System.Int32)"/>
             There are 2 scenarios
             <list type="number">
             <item>The fromSymbol is new i.e. the select statement has just been
             created, or a join extent has been added.</item>
             <item>The fromSymbol is old i.e. we are reusing a select statement.</item>
             </list>
            
             If we are not reusing the select statement, we have to complete the
             FROM clause with the alias
             <code>
             -- if the input was an extent
             FROM = [SchemaName].[TableName]
             -- if the input was a Project
             FROM = (SELECT ... FROM ... WHERE ...)
             </code>
            
             These become
             <code>
             -- if the input was an extent
             FROM = [SchemaName].[TableName] AS alias
             -- if the input was a Project
             FROM = (SELECT ... FROM ... WHERE ...) AS alias
             </code>
             and look like valid FROM clauses.
            
             Finally, we have to add the alias to the global list of aliases used,
             and also to the current symbol table.
             </summary>
             <param name="selectStatement"></param>
             <param name="inputVarName">The alias to be used.</param>
             <param name="fromSymbol"></param>
             <param name="addToSymbolTable"></param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.AddSortKeys(iAnywhere.Data.SQLAnywhere.SqlBuilder,System.Collections.Generic.IList{System.Data.Common.CommandTrees.DbSortClause})">
            <summary>
            Translates a list of SortClauses.
            Used in the translation of OrderBy 
            </summary>
            <param name="orderByClause">The SqlBuilder to which the sort keys should be appended</param>
            <param name="sortKeys"></param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.CreateNewSelectStatement(iAnywhere.Data.SQLAnywhere.SqlSelectStatement,System.String,System.Data.Metadata.Edm.TypeUsage,iAnywhere.Data.SQLAnywhere.Symbol@)">
            <summary>
            <see cref="!:CreateNewSelectStatement(SqlSelectStatement oldStatement, string inputVarName, TypeUsage inputVarType, bool finalizeOldStatement, out Symbol fromSymbol) "/>
            </summary>
            <param name="oldStatement"></param>
            <param name="inputVarName"></param>
            <param name="inputVarType"></param>
            <param name="fromSymbol"></param>
            <returns>A new select statement, with the old one as the from clause.</returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.CreateNewSelectStatement(iAnywhere.Data.SQLAnywhere.SqlSelectStatement,System.String,System.Data.Metadata.Edm.TypeUsage,System.Boolean,iAnywhere.Data.SQLAnywhere.Symbol@)">
             <summary>
             This is called after a relational node's input has been visited, and the
             input's sql statement cannot be reused.  <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbProjectExpression)"/>
            
             When the input's sql statement cannot be reused, we create a new sql
             statement, with the old one as the from clause of the new statement.
            
             The old statement must be completed i.e. if it has an empty select list,
             the list of columns must be projected out.
            
             If the old statement being completed has a join symbol as its from extent,
             the new statement must have a clone of the join symbol as its extent.
             We cannot reuse the old symbol, but the new select statement must behave
             as though it is working over the "join" record.
             </summary>
             <param name="oldStatement"></param>
             <param name="inputVarName"></param>
             <param name="inputVarType"></param>
             <param name="finalizeOldStatement"></param>
             <param name="fromSymbol"></param>
             <returns>A new select statement, with the old one as the from clause.</returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.EscapeSingleQuote(System.String,System.Boolean)">
            <summary>
            Before we embed a string literal in a SQL string, we should
            convert all ' to '', and enclose the whole string in single quotes.
            </summary>
            <param name="s"></param>
            <param name="isUnicode"></param>
            <returns>The escaped sql string.</returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.GetSqlPrimitiveType(System.Data.Metadata.Edm.TypeUsage)">
            <summary>
            Returns the sql primitive/native type name. 
            It will include size, precision or scale depending on type information present in the 
            type facets
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.HandaleCountExpression(System.Data.Common.CommandTrees.DbExpression)">
            <summary>
            Handles the expression represending DbLimitExpression.Limit and DbSkipExpression.Count.
            If it is a constant expression, it simply does to string thus avoiding casting it to the specific value
            (which would be done if <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbConstantExpression)"/> is called)
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.IsApplyExpression(System.Data.Common.CommandTrees.DbExpression)">
            <summary>
            This is used to determine if a particular expression is an Apply operation.
            This is only the case when the DbExpressionKind is CrossApply or OuterApply.
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.IsJoinExpression(System.Data.Common.CommandTrees.DbExpression)">
            <summary>
            This is used to determine if a particular expression is a Join operation.
            This is true for DbCrossJoinExpression and DbJoinExpression, the
            latter of which may have one of several different ExpressionKinds.
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.IsComplexExpression(System.Data.Common.CommandTrees.DbExpression)">
             <summary>
             This is used to determine if a calling expression needs to place
             round brackets around the translation of the expression e.
            
             Constants, parameters and properties do not require brackets,
             everything else does.
             </summary>
             <param name="e"></param>
             <returns>true, if the expression needs brackets </returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.IsCompatible(iAnywhere.Data.SQLAnywhere.SqlSelectStatement,System.Data.Common.CommandTrees.DbExpressionKind)">
            <summary>
            Determine if the owner expression can add its unique sql to the input's
            SqlSelectStatement
            </summary>
            <param name="result">The SqlSelectStatement of the input to the relational node.</param>
            <param name="expressionKind">The kind of the expression node(not the input's)</param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.QuoteIdentifier(System.String)">
            <summary>
            We use the normal box quotes for SQL server.  We do not deal with ANSI quotes
            i.e. double quotes.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.VisitExpressionEnsureSqlStatement(System.Data.Common.CommandTrees.DbExpression)">
            <summary>
            Simply calls <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.VisitExpressionEnsureSqlStatement(System.Data.Common.CommandTrees.DbExpression,System.Boolean)"/>
            with addDefaultColumns set to true
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.VisitExpressionEnsureSqlStatement(System.Data.Common.CommandTrees.DbExpression,System.Boolean)">
             <summary>
             This is called from <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.GenerateSql(System.Data.Common.CommandTrees.DbQueryCommandTree)"/> and nodes which require a
             select statement as an argument e.g. <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbIsEmptyExpression)"/>,
             <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbUnionAllExpression)"/>.
            
             SqlGenerator needs its child to have a proper alias if the child is
             just an extent or a join.
            
             The normal relational nodes result in complete valid SQL statements.
             For the rest, we need to treat them as there was a dummy
             <code>
             -- originally {expression}
             -- change that to
             SELECT *
             FROM {expression} as c
             </code>
             
             DbLimitExpression needs to start the statement but not add the default columns
             </summary>
             <param name="e"></param>
             <param name="addDefaultColumns"></param>
             <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.VisitFilterExpression(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpression,System.Boolean)">
             <summary>
             This method is called by <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbFilterExpression)"/> and
             <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbQuantifierExpression)"/>
            
             </summary>
             <param name="input"></param>
             <param name="predicate"></param>
             <param name="negatePredicate">This is passed from <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbQuantifierExpression)"/>
             in the All(...) case.</param>
             <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.WrapNonQueryExtent(iAnywhere.Data.SQLAnywhere.SqlSelectStatement,iAnywhere.Data.SQLAnywhere.ISqlFragment,System.Data.Common.CommandTrees.DbExpressionKind)">
            <summary>
            If the sql fragment for an input expression is not a SqlSelect statement
            or other acceptable form (e.g. an extent as a SqlBuilder), we need
            to wrap it in a form acceptable in a FROM clause.  These are
            primarily the
            <list type="bullet">
            <item>The set operation expressions - union all, intersect, except</item>
            <item>TVFs, which are conceptually similar to tables</item>
            </list>
            </summary>
            <param name="result"></param>
            <param name="sqlFragment"></param>
            <param name="expressionKind"></param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.IsBuiltinFunction(System.Data.Metadata.Edm.EdmFunction)">
            <summary>
            Is this a builtin function (ie) does it have the builtinAttribute specified?
            </summary>
            <param name="function"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.WriteFunctionName(iAnywhere.Data.SQLAnywhere.SqlBuilder,System.Data.Metadata.Edm.EdmFunction)">
             <summary>
            
             </summary>
             <param name="function"></param>
             <param name="result"></param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.NeedsInnerQuery(System.Collections.Generic.IList{System.Data.Common.CommandTrees.DbAggregate})">
            <summary>
            Helper method for the Group By visitor
            Returns true if at least one of the aggregates in the given list
            has an argument that is not a <see cref="T:System.Data.Common.CommandTrees.DbPropertyExpression"/> 
            over <see cref="T:System.Data.Common.CommandTrees.DbVariableReferenceExpression"/>
            </summary>
            <param name="aggregates"></param>
            <returns></returns>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.IsPropertyOverVarRef(System.Data.Common.CommandTrees.DbExpression)">
            <summary>
            Determines whether the given expression is a <see cref="T:System.Data.Common.CommandTrees.DbPropertyExpression"/> 
            over <see cref="T:System.Data.Common.CommandTrees.DbVariableReferenceExpression"/>
            </summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SqlGenerator.CurrentSelectStatement">
            <summary>
            The top of the stack
            </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SqlGenerator.IsParentAJoin">
            <summary>
            The top of the stack
            </summary>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SqlSelectStatement">
             <summary>
             A SqlSelectStatement represents a canonical SQL SELECT statement.
             It has fields for the 5 main clauses
             <list type="number">
             <item>SELECT</item>
             <item>FROM</item>
             <item>WHERE</item>
             <item>GROUP BY</item>
             <item>ORDER BY</item>
             </list>
             We do not have HAVING, since it does not correspond to anything in the DbCommandTree.
             Each of the fields is a SqlBuilder, so we can keep appending SQL strings
             or other fragments to build up the clause.
            
             We have a IsDistinct property to indicate that we want distict columns.
             This is given out of band, since the input expression to the select clause
             may already have some columns projected out, and we use append-only SqlBuilders.
             The DISTINCT is inserted when we finally write the object into a string.
             
             Also, we have a Top property, which is non-null if the number of results should
             be limited to certain number. It is given out of band for the same reasons as DISTINCT.
            
             The FromExtents contains the list of inputs in use for the select statement.
             There is usually just one element in this - Select statements for joins may
             temporarily have more than one.
            
             If the select statement is created by a Join node, we maintain a list of
             all the extents that have been flattened in the join in AllJoinExtents
             <example>
             in J(j1= J(a,b), c)
             FromExtents has 2 nodes JoinSymbol(name=j1, ...) and Symbol(name=c)
             AllJoinExtents has 3 nodes Symbol(name=a), Symbol(name=b), Symbol(name=c)
             </example>
            
             If any expression in the non-FROM clause refers to an extent in a higher scope,
             we add that extent to the OuterExtents list.  This list denotes the list
             of extent aliases that may collide with the aliases used in this select statement.
             It is set by <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbVariableReferenceExpression)"/>.
             An extent is an outer extent if it is not one of the FromExtents.
            
            
             </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlSelectStatement.WriteSql(iAnywhere.Data.SQLAnywhere.SqlWriter,iAnywhere.Data.SQLAnywhere.SqlGenerator)">
            <summary>
            Write out a SQL select statement as a string.
            We have to
            <list type="number">
            <item>Check whether the aliases extents we use in this statement have
            to be renamed.
            We first create a list of all the aliases used by the outer extents.
            For each of the FromExtents( or AllJoinExtents if it is non-null),
            rename it if it collides with the previous list.
            </item>
            <item>Write each of the clauses (if it exists) as a string</item>
            </list>
            </summary>
            <param name="writer"></param>
            <param name="sqlGenerator"></param>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SqlSelectStatement.IsDistinct">
            <summary>
            Do we need to add a DISTINCT at the beginning of the SELECT
            </summary>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SqlWriter">
            <summary>
            This extends StringWriter primarily to add the ability to add an indent
            to each line that is written out.
            </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlWriter.#ctor(System.Text.StringBuilder)">
            <summary>
            
            </summary>
            <param name="b"></param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlWriter.Write(System.String)">
            <summary>
            Reset atBeginningofLine if we detect the newline string.
            <see cref="M:iAnywhere.Data.SQLAnywhere.SqlBuilder.AppendLine"/>
            Add as many tabs as the value of indent if we are at the 
            beginning of a line.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.SqlWriter.WriteLine">
            <summary>
            
            </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.SqlWriter.Indent">
            <summary>
            The number of tabs to be added at the beginning of each new line.
            </summary>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SymbolPair">
            <summary>
            The SymbolPair exists to solve the record flattening problem.
            <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbPropertyExpression)"/>
            Consider a property expression D(v, "j3.j2.j1.a.x")
            where v is a VarRef, j1, j2, j3 are joins, a is an extent and x is a columns.
            This has to be translated eventually into {j'}.{x'}
            
            The source field represents the outermost SqlStatement representing a join
            expression (say j2) - this is always a Join symbol.
            
            The column field keeps moving from one join symbol to the next, until it
            stops at a non-join symbol.
            
            This is returned by <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbPropertyExpression)"/>,
            but never makes it into a SqlBuilder.
            </summary>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.SymbolTable">
            <summary>
            The symbol table is quite primitive - it is a stack with a new entry for
            each scope.  Lookups search from the top of the stack to the bottom, until
            an entry is found.
            
            The symbols are of the following kinds
            <list type="bullet">
            <item><see cref="T:iAnywhere.Data.SQLAnywhere.Symbol"/> represents tables (extents/nested selects/unnests)</item>
            <item><see cref="T:iAnywhere.Data.SQLAnywhere.JoinSymbol"/> represents Join nodes</item>
            <item><see cref="T:iAnywhere.Data.SQLAnywhere.Symbol"/> columns.</item>
            </list>
            
            Symbols represent names <see cref="M:iAnywhere.Data.SQLAnywhere.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbVariableReferenceExpression)"/> to be resolved, 
            or things to be renamed.
            </summary>
        </member>
        <member name="T:iAnywhere.Data.SQLAnywhere.TopClause">
            <summary>
            TopClause represents the a TOP expression in a SqlSelectStatement. 
            It has a count property, which indicates how many TOP rows should be selected and a 
            boolen WithTies property.
            </summary>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.TopClause.#ctor(iAnywhere.Data.SQLAnywhere.ISqlFragment,System.Boolean)">
            <summary>
            Creates a TopClause with the given topCount and withTies.
            </summary>
            <param name="topCount"></param>
            <param name="withTies"></param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.TopClause.#ctor(System.Int32,System.Boolean)">
            <summary>
            Creates a TopClause with the given topCount and withTies.
            </summary>
            <param name="topCount"></param>
            <param name="withTies"></param>
        </member>
        <member name="M:iAnywhere.Data.SQLAnywhere.TopClause.WriteSql(iAnywhere.Data.SQLAnywhere.SqlWriter,iAnywhere.Data.SQLAnywhere.SqlGenerator)">
            <summary>
            Write out the TOP part of sql select statement 
            It basically writes TOP (X) [WITH TIES].
            </summary>
            <param name="writer"></param>
            <param name="sqlGenerator"></param>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.TopClause.WithTies">
            <summary>
            Do we need to add a WITH_TIES to the top statement
            </summary>
        </member>
        <member name="P:iAnywhere.Data.SQLAnywhere.TopClause.TopCount">
            <summary>
            How many top rows should be selected.
            </summary>
        </member>
    </members>
</doc>
